/*
 * $Id: SBML2APM.java 128 2011-07-04 14:40:49Z niko-rodrigue $
 * $URL: https://sbfc.svn.sourceforge.net/svnroot/sbfc/trunk/src/org/sbfc/converter/sbml2apm/SBML2APM.java $
 *
 *
 * ==============================================================================
 * Copyright (c) 2008-2011 the copyright is held jointly by the individual
 * authors. See the file AUTHORS for the list of authors
 *
 * This file is part of The System Biology Format Converter (SBFC).
 *
 * SBFC is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SBFC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SBFC.  If not, see<http://www.gnu.org/licenses/>.
 * 
 * ==============================================================================
 * 
 */

package org.sbfc.converter.sbml2apm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.sbfc.converter.GeneralConverter;
import org.sbfc.converter.models.GeneralModel;
import org.sbfc.converter.models.SBMLModel;
import org.sbfc.converter.models.APMModel;
import org.sbml.jsbml.ASTNode;
import org.sbml.jsbml.AlgebraicRule;
import org.sbml.jsbml.AssignmentRule;
import org.sbml.jsbml.CVTerm;
import org.sbml.jsbml.Compartment;
import org.sbml.jsbml.Delay;
import org.sbml.jsbml.Event;
import org.sbml.jsbml.EventAssignment;
import org.sbml.jsbml.ExplicitRule;
import org.sbml.jsbml.FunctionDefinition;
import org.sbml.jsbml.KineticLaw;
import org.sbml.jsbml.ListOf;
import org.sbml.jsbml.LocalParameter;
import org.sbml.jsbml.Model;
import org.sbml.jsbml.NamedSBase;
import org.sbml.jsbml.Parameter;
import org.sbml.jsbml.RateRule;
import org.sbml.jsbml.Reaction;
import org.sbml.jsbml.Rule;
import org.sbml.jsbml.SBMLException;
import org.sbml.jsbml.SBase;
import org.sbml.jsbml.Species;
import org.sbml.jsbml.SpeciesReference;
import org.sbml.jsbml.StoichiometryMath;
import org.sbml.jsbml.Trigger;



/**
 * Converts an SBML file into an APM file.
 *  
 * @author Nicolas Rodriguez
 * @author Kedar nath Natarajan
 * @author Jean-Baptiste Pettit
 * @author Lu Li
 * @author David Grigsby
 * 
 * @version 1.2
 * 
 */
@SuppressWarnings("deprecation")
public class SBML2APM extends GeneralConverter{

	private String apmModel;

	private HashMap<Species, String> speciesFluxMap = new HashMap<Species, String>();
	private HashMap<Species, Boolean> isHasSubstanceUnits = new HashMap<Species, Boolean>();
	Vector<String> mathOperators;
	ListOf<SpeciesReference> products;
	ListOf<SpeciesReference> reactants;
	// We count parameters from:
	// - compartment (@constant!=false)
	// - global parameters (@constant!=false)
	// - species (@constant=true)
	// - local parameters
	private int nbParameters = 0;

	public final static Pattern idPattern = Pattern.compile("(_|[a-z]|[A-Z])(_|[a-z]|[A-Z]|[0-9])*");

	public final static Pattern plusMinusPattern = Pattern.compile("(\\+\\ \\-)");

	Model sbmlModel;

	private APMFormulaCompilerNoPiecewise apmFormulaCompiler = new APMFormulaCompilerNoPiecewise();
	private APMFormulaCompilerNoStepFunction apmStepFuncCompiler = new APMFormulaCompilerNoStepFunction();
	
	/**
	 * <b>Constructor SBML2APM.</b><br/> Main method of the biological model
	 * export from <a href="http://sbml.org/"><b>SBML</b></a> (Systems Biology
	 * Markup Language) to <a
	 * href="http://www.math.pitt.edu/~bard/apm/apm.html"><b>APM</b></a>.

	 * 
	 * jSBML is used to read and check the SBML file provided.<br/>
	 * 
	 *            Path of the SBML file to export
	 */
	public SBML2APM() {
		super();

	}


	private String createHeader() {
		
		String apmModel = "\n!\n" +
			"! This file is automatically generated with \n" +
			"! the System Biology Format Converter (http://sbfc.sourceforge.net/)\n" +
			"! from an SBML file.\n!\n";

		String modelName = sbmlModel.getName();

		if (modelName == null || modelName.trim().length() == 0) {
			modelName = sbmlModel.getId();
		}
		apmModel += "\n!\n! Model name = " + modelName + "\n!\n";

		// put all the bqmodel references as comment 
		for (CVTerm cvTerm : sbmlModel.getCVTerms()) {
			if (cvTerm.isModelQualifier()) {
				for (String uri : cvTerm.getResources()) {
					apmModel += "! " + cvTerm.getModelQualifierType().getElementNameEquivalent() + " " + uri + "\n";
				}
			}
		}
		apmModel +="!\n";
			
		return apmModel;
	}
	
	
	/**
	 * <b>Method of the export.</b><br/>
	 * 
	 * Use libSBML to read the SBML model object create before.<br/>
	 * 
	 * @param sbmlModel
	 *            SBML object create with the path provide to the constructor
	 * @throws SBMLException 
	 */
	public APMModel apmExport(SBMLModel sbmlmodel) throws SBMLException {

		System.out.println("SBML2APM : apmExport : Export in progress...");
		
		sbmlModel = sbmlmodel.getModel();

		apmModel = createHeader();		
		
		int varCount=0;
		int eqCount =0;
		int interCount =0;
		
		// TODO : include those only if needed
		// pow(x,y)=x^y\n" + "root(x,y)=y^(1/x)\n" + "
		// pow and root are inlined directly by jsbml now.
		//apmModel +="\n! some function definitions that are allowed in SBML but not valid in apm\n";
		//apmModel +="ceil(x)=flr(1+x)\n";
		
		// maximum delay allowed in integration
		//apmModel +="\n@delay=50\n";
		
		// SBML elements that we can export in APM
		ListOf<FunctionDefinition> functiondefinitions = sbmlModel.getListOfFunctionDefinitions();
		ListOf<Compartment> compartments = sbmlModel.getListOfCompartments();
		ListOf<Species> listOfSpecies = sbmlModel.getListOfSpecies();
		ListOf<Parameter> parameters = sbmlModel.getListOfParameters();
		ListOf<Rule> rules = sbmlModel.getListOfRules();
		ListOf<Reaction> reactions = sbmlModel.getListOfReactions();
		ListOf<Event> events = sbmlModel.getListOfEvents();
		
		mathOperators = new Vector<String>();

		mathOperators.add("exp");
		mathOperators.add("pow");
		mathOperators.add("root");
		mathOperators.add("sqrt"); // libsbml transformed root into sqrt !!
		mathOperators.add("eq");
		mathOperators.add("neq");
		mathOperators.add("gt");
		mathOperators.add("geq");
		mathOperators.add("lt");
		mathOperators.add("leq");
		mathOperators.add("sin");
		mathOperators.add("cos");
		mathOperators.add("tan");
		mathOperators.add("atan2");
		mathOperators.add("asin");
		mathOperators.add("acos");
		mathOperators.add("atan");
		mathOperators.add("sinh");
		mathOperators.add("cosh");
		mathOperators.add("tanh");
		mathOperators.add("log");
		mathOperators.add("log10");		
		mathOperators.add("ln");
		mathOperators.add("abs");
		mathOperators.add("pi");
		mathOperators.add("time");
		mathOperators.add("Time");
		mathOperators.add("delay");
		mathOperators.add("ceil");
		mathOperators.add("flr");
		
		// because of the e-notation
		mathOperators.add("e");
		mathOperators.add("E");
		
		// For the time variable (csymbol time)
		mathOperators.add("t");
		
		// This will be transformed into if/then/else statement
		// mathOperators.add("piecewise");
		mathOperators.add("if");
		mathOperators.add("then");
		mathOperators.add("else");

		// TODO : check sign produce for the event !!

		// TODO : SBML level 2 version 3 : InitialAssignment (first biomodel with one is out !!!)...
		// use the libSBML WS facility to remove InitialAssignment from the model ??
		
		// TODO : if there is a piecewise element inside a functionDefinition, we would need to flatten the functionDefinitions
		// of the model to be able to support properly the piecewise. Could be done with the libSBML WS facility too.
		// biomodels 316 and 317 have this problem + 255
		// May be we could define an apm function with 3 parameters that will do the if/then/else, then use this function
		// everywhere ??	
		
		// TODO : units check consistency : see if the libsbml WS could provide something like that.
		
		// TODO : does APM mind at all about long variable name nowadays (version 5.96 seems to be fine) !!!
		
		
		
		try {
			System.out.println("Building ID maps...");
		// TODO: Build all relevant ID maps
		// Parameters
			for (Parameter parameter : parameters) {
				buildIdMap(parameter);
			}
		// Compartments
			for (Compartment compartment : compartments) {		
				buildIdMap(compartment);	
			}
		// Species 
		// id map is needed here for the rules mathML replaceId
			for (Species species : listOfSpecies) {
				buildIdMap(species);
	
				if (!species.isHasOnlySubstanceUnits()) {
					if (species.getCompartmentInstance().getSpatialDimensions() > 0) {
						isHasSubstanceUnits.put(species, false);
					}
					if (species.getCompartmentInstance().getSpatialDimensions() == 0) {
						isHasSubstanceUnits.put(species, true);
					}
				} else if (species.isHasOnlySubstanceUnits()) {
					isHasSubstanceUnits.put(species, true);
				}
	
			}
		// Reactions Id Map : We need to build the id map for reactions before taking care of the rules
		// in case there are any reaction id inside the rules math formula.
			for (Reaction reaction : reactions) {
				buildIdMap(reaction);
				
				// This section builds the information for the species flux equations
				products = reaction.getListOfProducts();
				reactants = reaction.getListOfReactants();
	
				for (SpeciesReference reactant : reactants) {
	
					Species species = reactant.getSpeciesInstance();
					String speciesFlux = speciesFluxMap.get(species);
	
	
					String stoichiometryStr = "1";
					double stoichiometry = reactant.getStoichiometry();
					StoichiometryMath stoichiometryMath = reactant.getStoichiometryMath();
	
					if (stoichiometryMath != null
							&& stoichiometryMath.isSetMath()) {
						stoichiometryStr = stoichiometryMath.getMath().toFormula();
					} else if (stoichiometry != 0) {
						stoichiometryStr = Double.toString(stoichiometry);
					}
	
					if (speciesFlux == null) {
						speciesFlux = new String();
					}
					if (speciesFlux.length() != 0) {
						speciesFlux += " + ";
					}
					speciesFlux += "(-" + stoichiometryStr + " * "
						+ APMID.getAPMId(reaction.getId()) + ")";
					
					speciesFluxMap.put(species, speciesFlux);
					
					//System.out.println("Reactant flux map : id = " + species.getId());
					
				}
							
				for (SpeciesReference product : products) {
	
					Species species = product.getSpeciesInstance();
					String speciesFlux = speciesFluxMap.get(species);
	
					String stoichiometryStr = "1";
					double stoichiometry = product.getStoichiometry();
					StoichiometryMath stoichiometryMath = product.getStoichiometryMath();
	
					if (stoichiometryMath != null
							&& stoichiometryMath.isSetMath()) {
						stoichiometryStr = stoichiometryMath.getMath().toFormula();
					} else if (stoichiometry != 0) {
						stoichiometryStr = Double.toString(stoichiometry);
					}
	
					if (speciesFlux == null) {
						speciesFlux = new String();
					}
					if (speciesFlux.length() != 0) {
						speciesFlux += " + ";
					}
					speciesFlux += "( " + stoichiometryStr + " * "
						+ APMID.getAPMId(reaction.getId()) + ")";
					speciesFluxMap.put(species, speciesFlux);
				}
			}
		// Function Definition
			for (FunctionDefinition functiondefinition : functiondefinitions) {
				buildIdMap(functiondefinition);
			}
		//#########################
		//Begin compilation of Model Elements
		//#########################
			//apmModel +="\nModel " + sbmlModel.getName() + "\n";
			apmModel +="\nModel " + "\n";
		// Function Definition
			for (FunctionDefinition functiondefinition : functiondefinitions) {
				String funcdefin = printFunctionDefinition(functiondefinition);
				apmModel += "\n! FunctionDefinition id = " + functiondefinition.getId();
				if (functiondefinition.isSetName()) {
					apmModel += ", name = " + functiondefinition.getName() + "\n";
				} else {
					apmModel += "\n";
				}
				if (funcdefin == null) {
					System.out.println("Inconsistent mathML operators in Function Definition");
					apmModel += "! Inconsistent mathML operators in Function Definition, function ignored";
				} else {
					apmModel += "\t!" + funcdefin + "\n";
				}
			}

		// Compartments-Not required in APM
			apmModel+="! Compartments\n";
			for (Compartment compartment : compartments) {
				if (compartment.isConstant()) {
					apmModel +="!" +printConstantCompartment(compartment);
				} else {
					apmModel +="!" + printCompartment(compartment);
				}
			}
			apmModel+="! End Compartments\n";
		
		// Global Parameters
			apmModel+=" Parameters \n";
			System.out.println("Parameters...");
			//Rules--rules don't seem to be proper intermediates
				for (Rule rule : rules) {
					
					String ruleVariable = null;
					
					if (rule instanceof AlgebraicRule) {
						//ruleVariable = printAlgebraicRule(rule);
					} else { 
						//ruleVariable = printRuleParameter(rule);
					}
				if (ruleVariable == null) {
						//System.out.println("!Inconsistent mathML operators in Rule : " + rule.toString());				
					} else {
						nbParameters++;
						apmModel +=ruleVariable;
					}
				}
			//Parameters
				for (Parameter parameter : parameters) {
					String parameterVariable = null;
					if (parameter.isConstant()) {			
						parameterVariable=printParameterConstant(parameter);
					} else {
						parameterVariable =printParameter(parameter);
					}
					
					if (parameterVariable == null) {
						//System.out.println("!Inconsistent mathML operators in Parameter : " + rule.toString());				
					} else {
						apmModel +=parameterVariable; //Debug
						nbParameters++;
					}
				}
			
			apmModel+=" End Parameters \n\n";
		
		// Parameters, Rules, Reactions, Species---Extract Variables
			apmModel += " Variables\n";
			System.out.println("Variables...");
		//Parameter variables
			for (Parameter parameter : parameters) {
				String parameterVariable = null;
				if (!parameter.isConstant()) {
					parameterVariable = printParameter(parameter);
				} 
				if (parameterVariable == null) {
					//System.out.println("!Inconsistent mathML operators in Parameter : " + rule.toString());				
				} else {
					//apmModel +=parameterVariable; Debug
					//varCount++;
				}
			}
		//Rules--Variables
			for (Rule rule : rules) {
				String ruleVariable = null;
				if (rule instanceof AlgebraicRule) {
					//ruleVariable = printAlgebraicRule(rule);
				} else { 
					ruleVariable = printRuleVariable(rule);
				}
				if (ruleVariable == null) {
					//System.out.println("!Inconsistent mathML operators in Rule : " + rule.toString());				
				} else {
					apmModel +=ruleVariable;
					varCount++;
				}
			}
		
		// Species-Contains parameters and equations
			for (Species species : listOfSpecies) {
				if (species.isConstant()) {
					//nbParameters++;
					apmModel +=printConstantSpecies(species);
					varCount++;
				} else {
					String speciesVariable = printSpeciesVariable(species);
					
					if (speciesVariable == null) {
						//System.out.println("Inconsistent mathML operator in species " + species.getId()); // Should never happen
					} else {
						apmModel +=speciesVariable;
						varCount++;
					}
				}
			}
		
		apmModel += " End Variables\n\n";

		//Search Rules and Reactions determine any intermediates (e.g rate=k*ca-k*cb)
		System.out.println("Intermediates...");
		apmModel += " Intermediates\n";
		//Rules--rules don't seem to be proper intermediates
		for (Rule rule : rules) {
			
			String ruleVariable = null;
			
			if (rule instanceof AlgebraicRule) {
				//ruleVariable = printAlgebraicRule(rule);
			} else { 
				ruleVariable = printRuleIntermediate(rule);
			}
		if (ruleVariable == null) {
				//System.out.println("!Inconsistent mathML operators in Rule : " + rule.toString());				
			} else {
				apmModel +=ruleVariable;
				interCount++;
			}
		}
		// Reactions
		for (Reaction reaction : reactions) {
			String reactionmath = printReaction(reaction);
			if (reactionmath == null) {
				//System.out.println("Inconsistent mathML operators in Reaction " + reaction.getId());
				apmModel += "! Inconsistent mathML operators in Reaction " + reaction.getId();
			} else {
				apmModel +=reactionmath;
				interCount++;
			}
		}
		apmModel += "\n End Intermediates\n\n";
				
		// Rules, Reactions, Species---Extract Equations
		System.out.println("Equations...");
		apmModel += " Equations\n";
		//Rules
		for (Rule rule : rules) {
			String rulemath = null;
			if (rule instanceof AlgebraicRule) {
				rulemath = printAlgebraicRule(rule);
			} else { 
				rulemath = printRule(rule);
			}	
			if (rulemath == null) {
				//System.out.println("!Inconsistent mathML operators in Rule : " + rule.toString());				
			} else {
				apmModel +=rulemath;
				eqCount++;
			}
		}
		
		// Species-Contains parameters and equations
		for (Species species : listOfSpecies) {

			if (species.isConstant()) {
				//nbParameters++;
				//apmModel +=printConstantSpecies(species);
			} else {
				String speciesmath = printSpecies(species);
				if (speciesmath == null) {
					//System.out.println("Inconsistent mathML operator in species " + species.getId()); // Should never happen
				} else {
					apmModel +=speciesmath;
					eqCount++;
				}
			}
		}
		
		apmModel += " End Equations\n\n";

		
		// Events
		int i = 1;
		for (Event event : events) {

			apmModel += "\n";
				
			String eventId = event.getId();

			if (eventId == null || eventId.trim().length() == 0 || !idPattern.matcher(eventId).matches()) {
				eventId = "event" + i;
				event.setId(eventId);
			} 
			
			// System.out.println("Debug : Event id = " + eventId + ", " + event.getId());
			// TODO : put the metaid if defined, put an event comment !!?			
			
			apmModel += "! event : " + eventId + "\n";
			
			buildIdMap(event);
			
			i++;
			
			Delay delay = event.getDelay ();
			Trigger trigger = event.getTrigger ();
			ASTNode astTrigger = trigger.getMath();
			
			String infixASTTrigger = astTrigger.toFormula();
			infixASTTrigger = replaceIdInsideFormula(infixASTTrigger);
			
			if (trigger == null || !trigger.isSetMath()) {
				apmModel +="! the trigger of this event is null !!!\n";
				apmModel +="! event ignored.\n";
				continue;
			}

			if (infixASTTrigger == null) {
				apmModel +="! the trigger contain some unsupported math elements.\n";
				apmModel +="! event ignored.\n\n";				
				continue;
			}
			
			if (delay != null && delay.isSetMath()) {
				// output some comment and log with this message : ("Unable to handle events with delays");
				apmModel +="! unable to handle events with delays currently.\n";
				apmModel +="! event ignored.\n\n";
				continue;
			}
			
			
			
			apmModel +=APMID.getAPMId(eventId) + "=if (" + infixASTTrigger + ") then (1.5) else (0.2)\n";
			apmModel +="global 1 {" + APMID.getAPMId(eventId) + " - 1.1} {";
		
			int j = 1;
			int eventAssignmentSize = event.getNumEventAssignments();
			boolean invalidMath = false;
			
			for (EventAssignment eventAssignment : event.getListOfEventAssignments()) {
				String eventAssignmentMath = eventAssignment.getMath().toFormula();
				eventAssignmentMath = replaceIdInsideFormula(eventAssignmentMath);
				
				if (eventAssignmentMath == null) {
					invalidMath = true;

					if (j >= eventAssignmentSize) {
						apmModel +="}\n";
					}
					
					continue;
				}
				
				apmModel += eventAssignment.getVariable() + "=" + eventAssignmentMath;
				
				if (j < eventAssignmentSize) {
					apmModel +=";";
				} else {
					apmModel +="}\n";
				}
				
				j++;
			}
			
			if (eventAssignmentSize == 0) {
				apmModel +="}\n"; // closing the curly bracket in case of an invalid event with no eventAssignment 
			}
			if (invalidMath) {
				apmModel +="! some eventAssignment contained some unsupported math elements.\n";
				apmModel +="! the eventAssignment(s) was(were) ignored.\n\n";			
			}
			
		}
		//Remove the printing of the piecewise functions separate from the equations section
		/*
		if (apmFormulaCompiler.getPiecewiseMap().size() > 0) {
			
			apmModel += "! Piecewise functions : the mathML piecewise element is transformed into if/then/else expression\n";
			
			for (String piecewiseId : apmFormulaCompiler.getPiecewiseMap().keySet()) 
			{
				String ifThenElseFormula = apmFormulaCompiler.getPiecewiseMap().get(piecewiseId);
				ifThenElseFormula = replaceIdInsideFormula(ifThenElseFormula);
				
				//System.out.println(" " + piecewiseId + " = " + apmFormulaCompiler.getPiecewiseMap().get(piecewiseId));
				
				if (ifThenElseFormula != null) {
					apmModel += "\t!" + piecewiseId + "=" + ifThenElseFormula + "\n";
				} else {
					apmModel += "! Inconsistent mathML operators found in piecewise \n";
					apmModel += "! formula is : " + ifThenElseFormula + " \n";
				}
			}
		}
		*/
		

		apmModel +="\nEnd Model\n";
		
		//TODO: Set the sections for the .csv file here to be copied by the user as defined by stepfunctions or piecewise functions
		
		apmModel += "!Parameter Count:" + nbParameters + "\n";
		apmModel += "!Variable Count:" + varCount + "\n";
		apmModel += "!Intermediate Count:" + interCount + "\n";
		apmModel += "!Equation Count:" + eqCount + "\n";
		

		} catch(AssertionError err) {
			apmModel = createHeader();
			apmModel += "\n!\n! " + err.getMessage() + "\n!\n";
		}
		
		APMModel apmReturnModel = new APMModel();
		apmReturnModel.setModelFromString(apmModel);
				
		return apmReturnModel;
		

	}
	
	
	private String translatePiecewise(String infixFormula, ASTNode astNode) {			
		
		// imbricated piecewise are fine as only simple if/then/else are created (test biomodels 248, 237)
		
		infixFormula = infixFormula.trim();
		int indexPiecewise = infixFormula.indexOf("piecewise");
		if (indexPiecewise != -1) {
			
			//System.out.println("SBML2APM : translatePiecewise : initial formula = " + infixFormula);
			try {
				infixFormula = astNode.compile(apmFormulaCompiler).toString();
				infixFormula = replaceIdInsideFormula(infixFormula);
			} catch (SBMLException e) {
				e.printStackTrace();
			}
			//System.out.println("SBML2APM : translatePiecewise : translated formula = \n" + infixFormula);
		}
		
		return infixFormula;
	}
	private String translateStepFunc(String infixFormula, ASTNode astNode) {			
		//TODO: Add reference to the variable of which stepfunction defines it.
		// imbricated piecewise are fine as only simple if/then/else are created (test biomodels 248, 237)
		
		infixFormula = infixFormula.trim();
		int indexPiecewise = infixFormula.indexOf("stepfunc");
		
		if (indexPiecewise != -1) {
			//int stepFuncSize = apmStepFuncCompiler.getstepFuncMap().size();
			//System.out.println("SBML2APM : translateStepFunc : initial formula = " + infixFormula + ";" + stepFuncSize);
			//System.out.println("SBML2APM : translatePiecewise : initial formula = " + infixFormula);
			try {
				infixFormula = astNode.compile(apmStepFuncCompiler).toString();
				infixFormula = replaceIdInsideFormula(infixFormula);
			} catch (SBMLException e) {
				e.printStackTrace();
			}
			//System.out.println("SBML2APM : translatePiecewise : translated formula = \n" + infixFormula);
		}
		
		return infixFormula;
	}
	
	/**
	 * Function Definition(mathML) from SBML file is converted to infix notation by libSBML
	 *  and checked for supporting math functions.
	 *  Infix notation is passed as a Equation in APM
	 *  
	 *  SBML: lambda(x,y,formula)
	 *  APM : function_name(x,y) = formula
	 *  @param functiondefinition : mathML from SBML model
	 * 	@return : corresponding Supported equation for APM 
	 * @throws SBMLException 
	 */
	private String printFunctionDefinition(FunctionDefinition functiondefinition) throws SBMLException {

		String inputformula = functiondefinition.getMath().toFormula();
		
		//System.out.println("SBML2APM : printFunctionDefinition : jsbml original math = " + inputformula);
		
		inputformula = inputformula.replace("lambda(", "");

		ArrayList<String> functionParameters = new ArrayList<String>();

		StringTokenizer stcomma = new StringTokenizer(inputformula, ",");
		
		StringBuilder funcDef = new StringBuilder();
		StringBuilder formula = new StringBuilder();
		formula.append("(");
		
		String functionname;

		int count = 0;
		int stCommaNb = stcomma.countTokens();

		/*
		 * uses ",  as String tokenizer " if single then a variable if more than
		 * one, check for," ", (, ), / and add it to formula
		 */
		while (stcomma.hasMoreTokens()) {
			
			String read = stcomma.nextToken().trim();
			count++;
			if (read.contains(" ") || read.contains(" * ")
					|| read.contains("/") || read.contains(")")
					|| read.contains("(")) 
			{
				formula.append(read);
				
				if (count < stCommaNb) {
					formula.append(",");
				}
			
			} else {
				functionParameters.add(read);
			}
		}

		// getting the apmid instead of functionid from FunctionDefinition
		functionname = functiondefinition.getId();
		String apmid = APMID.getAPMId(functionname);
		funcDef.append(apmid + "(");
		
		// add the function parameters to the StringBuilder separated by ","
		for (int i = 0; i < functionParameters.size(); i++) {
			if (i < functionParameters.size() - 1) {
				funcDef.append(functionParameters.get(i) + ",");
			} else {
				funcDef.append(functionParameters.get(i));
			}
		}

		// We need to replace the ids inside the mathML in case of nested functionDefinitions with long names !!
		String formulaStr = replaceIdInsideFormula(formula.toString());
		
		//TODO: Check if piecewise function--add to comment if piecewise function
		int piecewiseSize = apmFormulaCompiler.getPiecewiseMap().size();
		String formulaFunction = "";
		formulaFunction = translatePiecewise(functiondefinition.getMath().toFormula(), functiondefinition.getMath());
		String piecewiseId ="";
		
		if (apmFormulaCompiler.getPiecewiseMap().size() - piecewiseSize > 0){
			int i=1;
			for (String piecewiseID : apmFormulaCompiler.getPiecewiseMap().keySet()) 
			{
				if(i==apmFormulaCompiler.getPiecewiseMap().size()){
					piecewiseId = apmFormulaCompiler.getPiecewiseMap().get(piecewiseID);
				}
				i++;
			}			
		}
		
		funcDef.append(")=" + formulaStr + "! " + formulaFunction + piecewiseId);
		
		//System.out.println("FunctionDefinition : id = " + functiondefinition.getId());
		//System.out.println("FunctionDefinition : apm version = " + funcDef.toString());
		
		if (matchMath(formulaStr, functionParameters, funcDef)) {
			return funcDef.toString();
		} else {
			String error = functiondefinition.getMath().toFormula();
			funcDef.append("!FunctionDef: " + error);
			return funcDef.toString();
			//return error;
		}

	}

	/**
	 * Matches whether the elements in the formula are consistent with supported math operators <br />
	 * Function takes input formula, and Arraylist of valid names 
	 * 
	 * Mainly used for Function Definition
	 * 
	 * @param formula : Input formula to be checked
	 * @return : boolean whether math is supported or not
	 * 
	 */
	private boolean matchMath(String formula,
			ArrayList<String> additionalValidNames, StringBuilder apmSB) {
		boolean support = true;

		Matcher mathMatcher = idPattern.matcher(formula);
		ArrayList<String> checkoperator = new ArrayList<String>();
		while (mathMatcher.find()) {
			checkoperator.add(mathMatcher.group());
			// check for id
		}

		for (String check : checkoperator) {

			if (APMID.getSBMLId(check) != null) {
			} else {
				if (mathOperators.contains(check) || check.startsWith("piecew")) 
				{
					// the String is valid
				} 
				else if (additionalValidNames != null
						&& additionalValidNames.contains(check)) 
				{
					// the String is valid
				} 
				else 
				{
					//System.out.println("SBML2APM : matchMath : the operator " + check + " is not supported by apm");
					//System.out.println("SBML2APM : matchMath : the formula is : " + formula);
					apmSB.append("! the operator " + check + " is not supported by apm\n");
					apmSB.append("! the formula is : " + formula + "\n");
					support = false;
				}
			}
		}

		return support;
	}

	/**
	 * 
	 * Matches whether the elements in the formula are consistent with supported math operators by {@link APMID#checkAPMId()}
	 *  
	 * @param formula : Input formula to be checked
	 * @return : boolean whether math is supported or not
	 */
	private boolean matchMath(String formula, StringBuilder apmSB) {
		boolean support = true;

		Matcher mathMatcher = idPattern.matcher(formula);
		ArrayList<String> checkoperators = new ArrayList<String>();
		while (mathMatcher.find()) {
			
			checkoperators.add(mathMatcher.group());
			// check for id
		}

		for (String check : checkoperators) {
			if (APMID.getSBMLId(check) != null) {
			} else {
				if (mathOperators.contains(check) || check.startsWith("piecew")) {
				} else {
					//System.out.println("SBML2APM : matchMath : the operator " + check + " is not supported by apm");
					//System.out.println("SBML2APM : matchMath : the formula is : " + formula);
					apmSB.append("! the operator " + check + " is not supported by apm\n");
					apmSB.append("! the formula is : " + formula + "\n");
					support = false;
				}

			}

		}

		return support;
	}

	/**
	 * Converts the math(reaction) to infix notation by libSBML, 
	 * Prints reaction information (Reaction id, name),  <br />
	 * Local parameters, Checks for consistent APM parameter length by {@link APMID#checkAPMId()}
	 *   
	 * @param reaction : Reaction element of SBML model
	 * @return : corresponding Infix reaction
	 * @throws SBMLException 
	 */
	private String printReaction(Reaction reaction) throws SBMLException {

		StringBuilder reactionStr = new StringBuilder();
		String reactionId = reaction.getId();

		// print all local parameters
		KineticLaw kineticLaw = reaction.getKineticLaw();
		String kineticLawStr = "";

		if (kineticLaw != null) {
			kineticLawStr = kineticLaw.getMath().toFormula();

			ListOf<LocalParameter> localParameters = kineticLaw.getListOfParameters();

			for (LocalParameter parameter : localParameters) {

				buildIdMap(parameter, reaction);
				String parameterId = parameter.getId();
				String localParameterId = parameterId + "_" + reactionId;

	

				if (parameter.isSetValue()) {
					//nbParameters++;
					//reactionStr.append(printLocalParameter(parameter,
					//		localParameterId));
				} else {
					// Error, a local parameter should always be constant
					//System.out.println("!Warning !! the local parameter " + localParameterId
							//+ " is not constant !!");
				}

				// replace other ids if they are not "apm valid"

				kineticLawStr = replaceIdInsideFormula(kineticLawStr, parameterId,
						localParameterId);

			}

			// replace other ids if they are not "apm valid"
			kineticLawStr = replaceIdInsideFormula(kineticLawStr);
			kineticLawStr = translatePiecewise(kineticLawStr, kineticLaw.getMath());

			// replace "+ -" by "-"
			kineticLawStr = replacePlusMinusInsideFormula(kineticLawStr);
		} else {			
			throw new AssertionError("!The model cannot be converted as there are some kineticLaw undefined.");
		}

		reactionStr.append("\n\t" + APMID.getAPMId(reaction.getId()) + "="
				+ kineticLawStr + "");
		

		reactionStr.append("\t! Reaction: id = " + reactionId);
		if (reaction.getName() != null
				&& reaction.getName().trim().length() != 0) {
			reactionStr.append("\t! name = " + reaction.getName());
		}
		// checks mathML for reaction
		if (matchMath(kineticLawStr.toString(), reactionStr))
			return reactionStr.toString();
		else
			return null;

	}
	
	

	/**
	 * Replaces the formula elements in reference to APMid 
	 * Function takes formula, OldID and new Id
	 * @param formula : Any formula in SBML model
	 * @return : formula with changed/replaced Id's
	 */
	private String replaceIdInsideFormula(String formula, String oldId,
			String newId) {

		StringBuffer formulaWithIdsBuffer = new StringBuffer();

		Matcher formulaMatcher = idPattern.matcher(formula);

		while (formulaMatcher.find()) {
			String id = formulaMatcher.group().trim();

			if (id.equals(oldId)) {
				id = newId;
			}

			formulaMatcher.appendReplacement(formulaWithIdsBuffer, id);
		}

		formulaMatcher.appendTail(formulaWithIdsBuffer);

		return formulaWithIdsBuffer.toString();
	}

	/**
	 * Replaces the formula elements in reference to APMid 
	 * 
	 * @param formula : Any formula in SBML model
	 * @return : formula with changed/replaced Id's
	 */
	 
	private String replaceIdInsideFormula(String formula) {

		StringBuffer formulaWithIdsBuffer = new StringBuffer();

		Matcher formulaMatcher = idPattern.matcher(formula);

		while (formulaMatcher.find()) {
			String id = formulaMatcher.group().trim();

			String newId = APMID.getAPMId(id);

			if (newId != null) {
				formulaMatcher.appendReplacement(formulaWithIdsBuffer, newId);
			}
		}

		formulaMatcher.appendTail(formulaWithIdsBuffer);

		return formulaWithIdsBuffer.toString();
	}

	/**
	 * Appends the "+" or "-" sign to parameters/elements, accordingly when it is a reactant or a product  
	 * @param formula 
	 * @return : formula with changed sign. 
	 */
	private String replacePlusMinusInsideFormula(String formula) {

		StringBuffer formulaWithIdsBuffer = new StringBuffer();

		Matcher formulaMatcher = plusMinusPattern.matcher(formula);

		while (formulaMatcher.find()) {

			formulaMatcher.appendReplacement(formulaWithIdsBuffer, "- ");
		}

		formulaMatcher.appendTail(formulaWithIdsBuffer);

		return formulaWithIdsBuffer.toString();
	}

	/**
	 * Prints information on Local parameters <br />
	 * also calls the check for consistent APMid length by {@link APMID#checkAPMId()}
	 * @param parameter
	 * @param id
	 * @return
	 */
	@SuppressWarnings("unused")
	private String printLocalParameter(LocalParameter parameter, String id) {
		StringBuilder paramStr = new StringBuilder();

		
		String apmId = APMID.getAPMId(id);

		paramStr.append("\t" + apmId + "=" + parameter.getValue() + "\n\n");
		
		paramStr.append(printLocalParameterComment(parameter));

		return paramStr.toString();

	}


	/**
	 * using libSBML changes the Rules(mathML) to Infix notation
	 *  
	 * @param rule
	 * @return
	 * @throws SBMLException 
	 */
	private String printRule(Rule rule) throws SBMLException {
		
		StringBuilder ruleStr = new StringBuilder();
		String variableId = null;
		
		/*Getting VariableId*/
		if(rule.isRate()) {
			variableId = ((RateRule)rule).getVariable();
			
		}
		else if(rule.isAssignment()) {
			variableId = ((AssignmentRule)rule).getVariable();
		}
		
		String apmId = APMID.getAPMId(variableId);
		String mathMLStr = rule.getMath().toFormula();
		mathMLStr = replaceIdInsideFormula(mathMLStr);
		//TODO: Check if piecewise function--add to comment if piecewise function
		int piecewiseSize = apmFormulaCompiler.getPiecewiseMap().size();
		mathMLStr = translatePiecewise(mathMLStr, rule.getMath());
		String piecewiseId ="";
		
		if (apmFormulaCompiler.getPiecewiseMap().size() - piecewiseSize > 0){
			int i=1;
			for (String piecewiseID : apmFormulaCompiler.getPiecewiseMap().keySet()) 
			{
				if(i==apmFormulaCompiler.getPiecewiseMap().size()){
					piecewiseId = apmFormulaCompiler.getPiecewiseMap().get(piecewiseID);
				}
				i++;
			}			
		}
		
		if (matchMath(mathMLStr, ruleStr)) {

			// mathMLStr = translatePiecewise(mathMLStr);

			if (rule.isRate()) {
				//Rate determined by the differential equation
				// Get the initial values or have that done before ?
				RateRule variable = (RateRule)rule;
				@SuppressWarnings("unused")
				String initialValue = "TODO";
				if (variable.getVariableInstance() instanceof Compartment) {
					initialValue = "" + ((Compartment) variable.getVariableInstance()).getSize();
				} else if (variable.getVariableInstance() instanceof Species) {
					
					// TODO : check which one of InitialAmount or InitialConcentration we should use !!!
					initialValue = "" + ((Species) variable.getVariableInstance()).getInitialAmount();
					
				} else if(variable.getVariableInstance() instanceof Parameter) {
					initialValue = "" + ((Parameter) variable.getVariableInstance()).getValue();
				}  

				//ruleStr.append("\t" + apmId + "=" + initialValue + "!Variable\n");
				ruleStr.append("\t$" + apmId + "=" + mathMLStr + "");
				
			} else if (rule.isAssignment()) {
				//ruleStr.append("\t" + apmId + "=" + mathMLStr + "");
				return null;
			}
			
			
		} else {
			// Print a warning to say that there are  	some unsupported functions
			//System.out.println("!RuleRule " + variableId + " ignored : there are some unsupported functions !!");
			ruleStr.append("!Rule ignored : there are some unsupported functions !!\n");
		}
		ruleStr.append("\t! " + rule.getElementName() + ": variable = "
				+ variableId + " " + piecewiseId + "\n");
		return ruleStr.toString();

	}
	/**
	 * using libSBML changes the Rules(mathML) to Infix notation
	 *  
	 * @param rule
	 * @return
	 * @throws SBMLException 
	 */
	private String printRuleIntermediate(Rule rule) throws SBMLException {
		//Intermediate rules are rules by assignment since they have no intial value
		StringBuilder ruleStr = new StringBuilder();
		String variableId = null;
		
		/*Getting VariableId*/
		if(rule.isRate()) {
			variableId = ((RateRule)rule).getVariable();
			
		}
		else if(rule.isAssignment()) {
			variableId = ((AssignmentRule)rule).getVariable();
		}
		
		String apmId = APMID.getAPMId(variableId);
		String mathMLStr = rule.getMath().toFormula();
		mathMLStr = replaceIdInsideFormula(mathMLStr);
		String stepFunctionFormula = mathMLStr;
		mathMLStr = translateStepFunc(mathMLStr, rule.getMath());
		
		if (matchMath(mathMLStr, ruleStr)) {

			//mathMLStr = translatePiecewise(mathMLStr);

			if (rule.isRate()) { 
				//Rates go in the equations sections-
				//Rate determined by the differential equation				
				return null;
			} else if (rule.isAssignment()) {
				AssignmentRule variable = (AssignmentRule)rule;
				@SuppressWarnings("unused")
				String initialValue = "TODO";
				if (variable.getVariableInstance() instanceof Compartment) {
					initialValue = "=" + ((Compartment) variable.getVariableInstance()).getSize();
				} else if (variable.getVariableInstance() instanceof Species) {
					
					// TODO : check which one of InitialAmount or InitialConcentration we should use !!!
					initialValue = "=" + ((Species) variable.getVariableInstance()).getInitialAmount();
				} else if(variable.getVariableInstance() instanceof Parameter) {
					initialValue = "=" + ((Parameter) variable.getVariableInstance()).getValue();
				} else {
					initialValue = "";
				}
				//ruleStr.append("\t" + apmId + initialValue + "");
				ruleStr.append("\t" + apmId + "=" + mathMLStr + "");
			}
			
		} else {
			// Print a warning to say that there are  	some unsupported functions
			//System.out.println("!IntRule " + variableId + " ignored : there are some unsupported functions !!");
			ruleStr.append("!Rule ignored : there are some unsupported functions !!" + mathMLStr + "");
		}
		ruleStr.append("\t!" + rule.getElementName() + ": Variable = "
				+ variableId);
		
		//If the variable contains a stepfunction include that as a comment so it can be used by the user in a csv file

		int indexPiecewise = stepFunctionFormula.indexOf("stepfunc");
		if (indexPiecewise != -1) {
			ruleStr.append("\t!" + stepFunctionFormula);
		}
		ruleStr.append("\n");
		return ruleStr.toString();
	}
	/**
	 * using libSBML changes the Rules(mathML) to Infix notation
	 *  
	 * @param rule
	 * @return
	 * @throws SBMLException 
	 */
	private String printRuleParameter(Rule rule) throws SBMLException {
		//Intermediate rules are rules by assignment since they have no initial value
		StringBuilder ruleStr = new StringBuilder();
		String variableId = null;
		
		/*Getting VariableId*/
		if(rule.isRate()) {
			variableId = ((RateRule)rule).getVariable();
			
		}
		else if(rule.isAssignment()) {
			variableId = ((AssignmentRule)rule).getVariable();
		}
		
		String apmId = APMID.getAPMId(variableId);
		String mathMLStr = rule.getMath().toFormula();
		mathMLStr = replaceIdInsideFormula(mathMLStr);
		//mathMLStr = translatePiecewise(mathMLStr, rule.getMath());
		
		//System.out.println("Rule : variable = " + variableId);

		
		if (matchMath(mathMLStr, ruleStr)) {

			//mathMLStr = translatePiecewise(mathMLStr);

			if (rule.isRate()) { 
				//Rates go in the equations sections-
				//Rate determined by the differential equation				
				return null;
			} else if (rule.isAssignment()) {
				AssignmentRule variable = (AssignmentRule)rule;
				String initialValue = "TODO";
				if (variable.getVariableInstance() instanceof Compartment) {
					initialValue = "=" + ((Compartment) variable.getVariableInstance()).getSize();
				} else if (variable.getVariableInstance() instanceof Species) {
					
					// TODO : check which one of InitialAmount or InitialConcentration we should use !!!
					initialValue = "=" + ((Species) variable.getVariableInstance()).getInitialAmount();
				} else if(variable.getVariableInstance() instanceof Parameter) {
					double ruleParameterValue = ((Parameter) variable.getVariableInstance()).getValue();
					//Check to make sure a value exists for the parameter, if not then print nothing so APM will initialize it as 1
					if (Double.isNaN(ruleParameterValue)) {
						initialValue = "\t! Not assigned";
					} else {
						initialValue = "=" + ruleParameterValue;
					}
				} else {
					initialValue = "";
				}
				ruleStr.append("\t" + apmId + initialValue);
				//ruleStr.append("\t!Test Intermediate" + apmId + "=" + mathMLStr + "");
			}
			
		} else {
			// Print a warning to say that there are  	some unsupported functions
			//System.out.println("!IntRule " + variableId + " ignored : there are some unsupported functions !!");
			ruleStr.append("!Rule ignored : there are some unsupported functions !!\n");
		}
		ruleStr.append("\t!RuleParameter " + rule.getElementName() + ": variable = "
				+ variableId + "\n");
		return ruleStr.toString();
	}
	/**
	 * using libSBML changes the Rules(mathML) to Infix notation
	 *  
	 * @param rule-variable only
	 * @return
	 * @throws SBMLException 
	 */
	private String printRuleVariable(Rule rule) throws SBMLException {
		
		StringBuilder ruleStr = new StringBuilder();
		String variableId = null;
		
		/*Getting VariableId*/
		if(rule.isRate()) {
			variableId = ((RateRule)rule).getVariable();
			
		}
		else if(rule.isAssignment()) {
			variableId = ((AssignmentRule)rule).getVariable();
		}
		
		String apmId = APMID.getAPMId(variableId);
		String mathMLStr = rule.getMath().toFormula();
		mathMLStr = replaceIdInsideFormula(mathMLStr);
		//mathMLStr = translatePiecewise(mathMLStr, rule.getMath());
		
		//System.out.println("Rule : variable = " + variableId);

		
		if (matchMath(mathMLStr, ruleStr)) {

			// mathMLStr = translatePiecewise(mathMLStr);

			if (rule.isRate()) {
				//Rate determined by the differential equation
				// Get the initial values or have that done before ?
				RateRule variable = (RateRule)rule;
				String initialValue = "TODO";
				if (variable.getVariableInstance() instanceof Compartment) {
					initialValue = "" + ((Compartment) variable.getVariableInstance()).getSize();
				} else if (variable.getVariableInstance() instanceof Species) {
					
					// TODO : check which one of InitialAmount or InitialConcentration we should use !!!
					initialValue = "" + ((Species) variable.getVariableInstance()).getInitialAmount();
					
				} else if(variable.getVariableInstance() instanceof Parameter) {
					initialValue = "" + ((Parameter) variable.getVariableInstance()).getValue();
				}  

				ruleStr.append("\t" + apmId + "=" + initialValue + "!Variable-From Rule\n");
				//ruleStr.append("\t$" + apmId + "=" + mathMLStr + "");
				
			} else
				return null;
			
		} 
		
		return ruleStr.toString();

	}
	/**
	 * using libSBML changes the Rules(mathML) to Infix notation
	 *  
	 * @param rule
	 * @return
	 * @throws SBMLException 
	 */
	private String printAlgebraicRule(Rule rule) throws SBMLException {
		
		StringBuilder ruleStr = new StringBuilder();

		String mathMLStr = rule.getMath().toFormula();
		mathMLStr = replaceIdInsideFormula(mathMLStr);
		
		//System.out.println("Algebraic Rule");
		
		if (matchMath(mathMLStr, ruleStr)) {
			ruleStr.append("! " + rule.getElementName() + "\n");
			ruleStr.append("! Warning-Algebraic Rule, " + rule.getElementName() + " are not supported at the moment.\n");
			ruleStr.append("! " + mathMLStr + " = 0\n");
			
			return ruleStr.toString();
		} else {
			// TODO : Print a warning to say that there are some unsupported functions
			return null;
		}


	}

	/**
	 * Checks for Consistent APMid {@link APMID#checkAPMId()}<br/>
	 * Checks for initial Concentration and/or Initial Amount is defined
	 * Checks for Spatial Dimensions(Compartments), and accordingly returns Species Units <br/>
	 * Checks for Species Boundary Condition and Rules, 
	 * 
	 * @param species : Species Element of SBML Model
	 * @return : SpeciesFluxMap 
	 */
	private String printSpecies(Species species) {
		StringBuilder speciesStr = new StringBuilder();
		String checkmath = null;
		
		String id = species.getId();
		
		boolean isAffectedByRule = false;
		@SuppressWarnings("unused")
		boolean needInit = true;
		@SuppressWarnings("unused")
		boolean auxDeclaration = false;
		
		for (Rule rule : sbmlModel.getListOfRules()) {
			if (rule instanceof ExplicitRule) {
				if(id.equals(((ExplicitRule) rule).getVariable())) { 
					isAffectedByRule = true;
				
					needInit = false; // The init is done when writing the rule in fact
				}
			}
		}

		id = APMID.getAPMId(species.getId());
		
		@SuppressWarnings("unused")
		String apmModifier = "init "; 
		
		if (!isAffectedByRule && (!hasReaction(id) || (hasReaction(id) && species.isBoundaryCondition() == true))) {
			apmModifier = "\t"; 
			auxDeclaration = true;
			// int nbEvent = getNbAffectingEvent(species); Do we check to see if some event are involved ??
		}
		/*
		if (needInit) {
			if (species.isSetInitialAmount()
					&& species.isSetInitialConcentration()) {

				throw new AssertionError("!Error in model, both Initial concentration and Initial amount defined");

			} else if (species.isSetInitialAmount()) {
				speciesStr.append("\t" + id + "=" + species.getInitialAmount()
						+ "!" + apmModifier + "");

			} else if (species.isSetInitialConcentration()) {
				speciesStr.append("\t" + id + "="
						+ species.getInitialConcentration() + "!" + apmModifier + "");

			} else {
				speciesStr.append("!WARNING : no initial state for this species\n");
				speciesStr.append("\t" + id + "=0\n");
			}
		}
		*/
		//if (auxDeclaration) {
		//	speciesStr.append("\t" + id + "=" + id + "\n");
		//}
		
		if (species.isBoundaryCondition()) {
			if (!isAffectedByRule && !hasEvent(species.getId())) {

				speciesStr.append("\t$" + id + "=0" + "\t");
				speciesStr
				.append("!WARNING speciesID: "
						+ species.getId()
						+ ", constant= false "
						+ " , boundaryCondition = "
						+ species.isBoundaryCondition()
						+ " but is not involved in assignmentRule, rateRule or events !"
						+ "\n");

			}
		} else if (!species.isBoundaryCondition()) {
			// valid assignment rule/rate rule
			if (!isAffectedByRule) {
				// check if species is reactant/product
				if (speciesFluxMap.get(species) != null
						&& !(isHasSubstanceUnits.get(species))) {

					String sbmlId = species.getCompartmentInstance().getId();
					String apmId = APMID.getAPMId(sbmlId);
					checkmath = " (1/(" + apmId	+ "))*(" + speciesFluxMap.get(species) + ")";
					speciesStr.append("\t$" + id + "=" + "(1/(" + apmId
							+ "))*(" + speciesFluxMap.get(species) + ")\n");
				} else if (speciesFluxMap.get(species) != null) {
					speciesStr.append("\t$" + id + "="
							+ speciesFluxMap.get(species) + "\n");

				}
			}
		}
		//speciesStr.append(printSpeciesComment(species));
		if (checkmath != null) {
			if (matchMath(checkmath, speciesStr))
				return speciesStr.toString();
			else
				return null;
		}else
			return speciesStr.toString();
	}

	/**
	 * Checks for Consistent APMid {@link APMID#checkAPMId()}<br/>
	 * Checks for initial Concentration and/or Initial Amount is defined
	 * Checks for Spatial Dimensions(Compartments), and accordingly returns Species Units <br/>
	 * Checks for Species Boundary Condition and Rules, 
	 * 
	 * @param species : Species Element of SBML Model
	 * @return : SpeciesFluxMap 
	 */
	private String printSpeciesVariable(Species species) {
		StringBuilder speciesStr = new StringBuilder();
		@SuppressWarnings("unused")
		String checkmath = null;
		
		String id = species.getId();
		
		boolean isAffectedByRule = false;
		boolean needInit = true;
		@SuppressWarnings("unused")
		boolean auxDeclaration = false;
		
		for (Rule rule : sbmlModel.getListOfRules()) {
			if (rule instanceof ExplicitRule) {
				if(id.equals(((ExplicitRule) rule).getVariable())) { 
					isAffectedByRule = true;
				
					needInit = false; // The init is done when writing the rule in fact
				}
			}
		}

		id = APMID.getAPMId(species.getId());
		
		String apmModifier = "init "; 
		
		if (!isAffectedByRule && (!hasReaction(id) || (hasReaction(id) && species.isBoundaryCondition() == true))) {
			apmModifier = "Is not affected by rule or reaction"; 
			auxDeclaration = true;
			// int nbEvent = getNbAffectingEvent(species); Do we check to see if some event are involved ??
		}

		if (needInit) {
			if (species.isSetInitialAmount()
					&& species.isSetInitialConcentration()) {

				throw new AssertionError("!Error in model, both Initial concentration and Initial amount defined");

			} else if (species.isSetInitialAmount()) {
				speciesStr.append("\t" + id + "=" + species.getInitialAmount()
						+ "\t!" + apmModifier + "");

			} else if (species.isSetInitialConcentration()) {
				speciesStr.append("\t" + id + "="
						+ species.getInitialConcentration() + "\t!" + apmModifier + "");

			} else {
				//speciesStr.append("!WARNING : no initial state for this species\n");
				//speciesStr.append("\t" + id + "=0\n");
			}
		}


		speciesStr.append(printSpeciesComment(species));

			return speciesStr.toString();
	}
	/**
	 * Checks if an SBML element, represented by the id passed as argument, is affected by a rule. 
	 *  
	 * @param id an SBML element id.
	 * @return : true if element is affected by a rule  
	 */
	private boolean hasRule(String id) {
		for (Rule rule : sbmlModel.getListOfRules()) {
			if (rule instanceof ExplicitRule) {
				if (id.equals(((ExplicitRule) rule).getVariable())) {
					return true;
				}
			}

		}
		
		return false;
	}
	
	/**
	 * Checks if an SBML element, represented by the id passed as argument, is affected by an event. 
	 *  
	 * @param id an SBML element id.
	 * @return : true if element is affected by an event  
	 */
	private boolean hasEvent(String id) {
		for (Event event : sbmlModel.getListOfEvents()) {
			
			for (EventAssignment eventAssgnt : event.getListOfEventAssignments()) {
				if (eventAssgnt.getVariable().equals(id)) {
					return true;
				}
			}
		}
		
		return false;
	}

	/**
	 * Checks if a Species, represented by the id passed as argument, is used as reactant or product in a reaction. 
	 *  
	 * @param id a Species id.
	 * @return : true if the species is affected by Reaction  
	 */
	private boolean hasReaction(String id) {
		for (Reaction reaction : sbmlModel.getListOfReactions()) {
			
			for (SpeciesReference speciesRef : reaction.getListOfReactants()) {
				if (speciesRef.getSpecies().equals(id)) {
					return true;
				}
			}
			for (SpeciesReference speciesRef : reaction.getListOfProducts()) {
				if (speciesRef.getSpecies().equals(id)) {
					return true;
				}
			}
		}
		
		return false;
	}
	
	/**
	 * Prints Constant species and calls {@link APMID#checkAPMId()}
	 * Also checks for Intial concentration or amount defined
	 * @param species
	 * @return
	 */
	private String printConstantSpecies(Species species) {
		StringBuilder speciesStr = new StringBuilder();

		String id = APMID.getAPMId(species.getId());

		if (species.isSetInitialAmount()
				&& species.isSetInitialConcentration()) {

			throw new AssertionError("Error in model, both Initial concentration and Initial amount defined");

		} else if (species.isSetInitialAmount()) {
			speciesStr.append("\t" + id + "=" + species.getInitialAmount()
					+ "\n\n");

		} else if (species.isSetInitialConcentration()) {
			
			speciesStr.append("\t" + id + "="
					+ species.getInitialConcentration() + "\n\n");
		}
		speciesStr.append(printSpeciesComment(species));
		// todo completed
		return speciesStr.toString();
	}

	/**
	 * Adds Species Information <br />
	 * Checks for Rule and Boundary condition for species(!= Constant)
	 * 
	 * @param species : Element in SBML model
	 * @return : species Flux Map
	 */
	private String printSpeciesComment(Species species) {

		StringBuilder commentStr = new StringBuilder();
		String id = species.getId();
		String name = species.getName();

		if (name == null || name.trim().length() == 0) {
			name = id;
		}

		commentStr.append("\t! Species: ");
		commentStr.append("  id = " + id);
		commentStr.append(", name = " + name);
		if (species.getCompartment()!=null)
			commentStr.append("; Compartment:" + species.getCompartment());
		
		if (species.isConstant()) {
			commentStr.append(", constant");
		} else {
			// check for boundary condition and then display
			if (species.isBoundaryCondition()) {
				if (hasRule(id)) {
					commentStr.append(", involved in a rule ");
				} else if (!hasRule(id)) {
					
				}
			} else if (!species.isBoundaryCondition()) {
				// affected by rules or kinetic law not both
				if (hasRule(id)) {
					commentStr.append(", defined in a rule ");
				} else if (speciesFluxMap.get(species) != null) {
					commentStr.append(", affected by kineticLaw");
				} else {
					commentStr.append("\n! Warning species is not changed by either rules or reactions\n");
				}
			}

			int nbEvent = getNbAffectingEvent(species);
			
			if (nbEvent > 0) {
				commentStr.append("! Species is changed by " + nbEvent + " event(s)");
			}

		}
		commentStr.append("\n");

		return commentStr.toString();
	}

	
	/**
	 * Returns the number of event that have an assignment affecting the element passed as argument.
	 * 
	 * @param element and SBMl element
	 * 
	 * @return the number of event that have an assignment affecting the element passed as argument.
	 */
	private int getNbAffectingEvent(SBase element) {
		
		int n = 0;
		if(element instanceof NamedSBase) {
			String elementId = ((NamedSBase) element).getId();
			
			for (Event event : sbmlModel.getListOfEvents()) {
				for (EventAssignment eventAssignment : event.getListOfEventAssignments()) {
					if (elementId.equals(eventAssignment.getVariable())) {
						n++;
						break;
					}
				}
			}
		}
		
		return n;
	}
	
	

	/**
	 * 
	 * Adds parameter information as comments<br/> 
	 * Checks for whether parameter has a rule , or else gives a warning
	 *  
	 * @param : Parameter element of SBML
	 * @return : parameter information with Equation
	 */
	private String printParameter(Parameter parameter) {
		StringBuilder paramStr = new StringBuilder();

		boolean hasRule = hasRule(parameter.getId());
		
		/*
		if (!hasRule && !hasEvent(parameter.getId())) {
			paramStr.append("! Warning parameter " + parameter.getId()
					+ " is not constant, it should be controlled by a Rule and/or events" + "\n");
		}
		*/
		
		if (!hasRule) {
			String id = APMID.getAPMId(parameter.getId());

			paramStr.append("\t" + id + "=" + parameter.getValue() + "");
		} else
			return null;
		
		paramStr.append(printParameterComment(parameter));
		
		return paramStr.toString();
	}

	/**
	 * 
	 * Adds parameter information as comments and 
	 * limits and changes length of elements wrt APM
	 * 
	 * @param parameter : Parameter Element of SBML model
	 * @return : constant Parameter with initial value
	 */
	private String printParameterConstant(Parameter parameter) {
		StringBuilder paramStr = new StringBuilder();

		String id = APMID.getAPMId(parameter.getId());

		paramStr.append("\t" + id + "=" + parameter.getValue());
		
		paramStr.append(printParameterComment(parameter));
		return paramStr.toString();
	}

	/**
	 * Adds parameter information as comments <br /> 
	 * Checks whether parameter is a local parameter or a global parameter
	 * 
	 * @param Parameter :  Element of SBML Model
	 * @return : parameter information as string
	 */
	private String printParameterComment(Parameter parameter) {

		StringBuilder commentStr = new StringBuilder();

		String id = parameter.getId();
		String name = parameter.getName();

		if (name == null || name.trim().length() == 0) {
			name = id;
		}

		commentStr.append("\t! Parameter: ");
		commentStr.append("  id =  " + id);
		commentStr.append(", name = " + name);

		// find isConstant()
		if (parameter.isConstant()) {
			commentStr.append(", constant");
		}
		if (hasRule(id)) {
			commentStr.append(", defined by a Rule");
		}

		commentStr.append("\n");

		return commentStr.toString();
	}
	
	/**
	 * Adds parameter information as comments <br /> 
	 * Checks whether parameter is a local parameter or a global parameter
	 * 
	 * @param Parameter :  Element of SBML Model
	 * @return : parameter information as string
	 */
	private String printLocalParameterComment(LocalParameter parameter) {

		StringBuilder commentStr = new StringBuilder();

		String id = parameter.getId();
		String name = parameter.getName();

		if (name == null || name.trim().length() == 0) {
			name = id;
		}

		commentStr.append("\t! Local Parameter: ");
		commentStr.append("  id =  " + id);
		commentStr.append(", name = " + name);
		commentStr.append("\n");

		return commentStr.toString();
	}

	/**
	 * Adds compartment information as comments<br/> 
	 * Checks for whether compartment has a rule , or else gives a warning
	 * 
	 * @param compartment : Compartment element of SBML
	 * @return : Compartment information with Equation
	 */
	private String printCompartment(Compartment compartment) {

		StringBuilder compStr = new StringBuilder();

		compStr.append(printCompartmentComment(compartment));
		if (!hasRule(compartment.getId())) {
			compStr.append("! Warning compartment " + compartment.getId()
					+ " has no rule and is not constant" + "\n");
		}

		return compStr.toString();
	}

	/**
	 * Prints compartment comments: 
	 * id, name, constant or defined by a rule
	 * @param : compartment : Compartment element from SBML model
	 * @return : compartment information
	 */
	private String printCompartmentComment(Compartment compartment) {

		StringBuilder compCommentStr = new StringBuilder();

		String id = compartment.getId();
		String name = compartment.getName();

		if (name == null || name.trim().length() == 0) {
			name = id;
		}

		compCommentStr.append("! Compartment: id = " + id + ", name = " + name);

		if (compartment.isConstant()) {
			compCommentStr.append(", constant");
		} else if (hasRule(id)) {
			compCommentStr.append(", defined by a Rule");
		}

		compCommentStr.append("\n");

		return compCommentStr.toString();
	}

	/**
	 * Adds compartment information as comments and 
	 * limits and changes length of elements wrt APM
	 * @param compartment : Compartment element of SBML model 
	 * @return : constant compartment with initial size
	 */
	private String printConstantCompartment(Compartment compartment) {

		StringBuilder compStr = new StringBuilder();

		String id = APMID.getAPMId(compartment.getId());

		compStr.append("\t" + id + "=" + compartment.getSize());
		
		compStr.append(printCompartmentComment(compartment));

		return compStr.toString();

	}

	private void buildIdMap(SBase element) {

		String id = ((NamedSBase)element).getId();

		APMID apmId = new APMID(id);
		apmId.checkAPMId();
	}

	private void buildIdMap(LocalParameter parameter, Reaction reaction) {

		String id = parameter.getId();
		APMID apmId = new APMID(id, reaction.getId());
		apmId.checkAPMId();

	}




	public GeneralModel convert(GeneralModel model) {
		
		try {
			return apmExport((SBMLModel)model);
		} catch (SBMLException e) {
			e.printStackTrace();
		}

		return null;
	}


	public String getResultExtension() {
		return ".apm";
	}
}

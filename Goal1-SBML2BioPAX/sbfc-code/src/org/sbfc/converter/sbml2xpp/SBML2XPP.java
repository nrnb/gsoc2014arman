/*
 * $Id: SBML2XPP.java 128 2011-07-04 14:40:49Z niko-rodrigue $
 * $URL: svn://svn.code.sf.net/p/sbfc/code/trunk/src/org/sbfc/converter/sbml2xpp/SBML2XPP.java $
 *
 *
 * ==============================================================================
 * Copyright (c) 2008-2011 the copyright is held jointly by the individual
 * authors. See the file AUTHORS for the list of authors
 *
 * This file is part of The System Biology Format Converter (SBFC).
 *
 * SBFC is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SBFC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SBFC.  If not, see<http://www.gnu.org/licenses/>.
 * 
 * ==============================================================================
 * 
 */

package org.sbfc.converter.sbml2xpp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.sbfc.converter.GeneralConverter;
import org.sbfc.converter.models.GeneralModel;
import org.sbfc.converter.models.SBMLModel;
import org.sbfc.converter.models.XPPModel;
import org.sbml.jsbml.ASTNode;
import org.sbml.jsbml.AlgebraicRule;
import org.sbml.jsbml.AssignmentRule;
import org.sbml.jsbml.CVTerm;
import org.sbml.jsbml.Compartment;
import org.sbml.jsbml.Delay;
import org.sbml.jsbml.Event;
import org.sbml.jsbml.EventAssignment;
import org.sbml.jsbml.ExplicitRule;
import org.sbml.jsbml.FunctionDefinition;
import org.sbml.jsbml.KineticLaw;
import org.sbml.jsbml.ListOf;
import org.sbml.jsbml.LocalParameter;
import org.sbml.jsbml.Model;
import org.sbml.jsbml.NamedSBase;
import org.sbml.jsbml.Parameter;
import org.sbml.jsbml.RateRule;
import org.sbml.jsbml.Reaction;
import org.sbml.jsbml.Rule;
import org.sbml.jsbml.SBMLException;
import org.sbml.jsbml.SBase;
import org.sbml.jsbml.Species;
import org.sbml.jsbml.SpeciesReference;
import org.sbml.jsbml.StoichiometryMath;
import org.sbml.jsbml.Trigger;
import org.sbml.jsbml.util.compilers.FormulaCompilerNoPiecewise;



/**
 * Converts an SBML file into an XPP file.
 *  
 * @author Nicolas Rodriguez
 * @author Kedar nath Natarajan
 * @author Jean-Baptiste Pettit
 * @author Lu Li
 * 
 * 
 * @version 1.2
 * 
 */
@SuppressWarnings("deprecation")
public class SBML2XPP extends GeneralConverter{

	private String xppModel;

	private HashMap<Species, String> speciesFluxMap = new HashMap<Species, String>();
	private HashMap<Species, Boolean> isHasSubstanceUnits = new HashMap<Species, Boolean>();
	Vector<String> mathOperators;
	ListOf<SpeciesReference> products;
	ListOf<SpeciesReference> reactants;
	// We count parameters from:
	// - compartment (@constant!=false)
	// - global parameters (@constant!=false)
	// - species (@constant=true)
	// - local parameters
	private int nbParameters = 0;

	public final static Pattern idPattern = Pattern.compile("(_|[a-z]|[A-Z])(_|[a-z]|[A-Z]|[0-9])*");

	public final static Pattern plusMinusPattern = Pattern.compile("(\\+\\ \\-)");

	Model sbmlModel;

	private FormulaCompilerNoPiecewise xppFormulaCompiler = new FormulaCompilerNoPiecewise();

	/**
	 * <b>Constructor SBML2XPP.</b><br/> Main method of the biological model
	 * export from <a href="http://sbml.org/"><b>SBML</b></a> (Systems Biology
	 * Markup Language) to <a
	 * href="http://www.math.pitt.edu/~bard/xpp/xpp.html"><b>XPP</b></a>.

	 * 
	 * jSBML is used to read and check the SBML file provided.<br/>
	 * 
	 *            Path of the SBML file to export
	 */
	public SBML2XPP() {
		super();

	}


	private String createHeader() {
		
		String xppModel = "\n#\n" +
			"# This file is automatically generated with \n" +
			"# the System Biology Format Converter (http://sbfc.sourceforge.net/)\n" +
			"# from an SBML file.\n#\n";

		String modelName = sbmlModel.getName();

		if (modelName == null || modelName.trim().length() == 0) {
			modelName = sbmlModel.getId();
		}
		xppModel += "\n#\n# Model name = " + modelName + "\n#\n";

		// put all the bqmodel references as comment 
		for (CVTerm cvTerm : sbmlModel.getCVTerms()) {
			if (cvTerm.isModelQualifier()) {
				for (String uri : cvTerm.getResources()) {
					xppModel += "# " + cvTerm.getModelQualifierType().getElementNameEquivalent() + " " + uri + "\n";
				}
			}
		}
		xppModel +="#\n";
			
		return xppModel;
	}
	
	
	/**
	 * <b>Method of the export.</b><br/>
	 * 
	 * Use libSBML to read the SBML model object create before.<br/>
	 * 
	 * @param sbmlModel
	 *            SBML object create with the path provide to the constructor
	 * @throws SBMLException 
	 */
	public XPPModel xppExport(SBMLModel sbmlmodel) throws SBMLException {

		System.out.println("SBML2XPP : xppExport : Export in progress...");

		sbmlModel = sbmlmodel.getModel();

		xppModel = createHeader();		
		
		// TODO : include those only if needed
		// pow(x,y)=x^y\n" + "root(x,y)=y^(1/x)\n" + "
		// pow and root are inlined directly by jsbml now.
		xppModel +="\n# some function definitions that are allowed in SBML but not valid in xpp\n";
		xppModel +="ceil(x)=flr(1+x)\n";
		
		// maximum delay allowed in integration
		xppModel +="\n@delay=50\n";

		// SBML elements that we can export in XPP
		ListOf<FunctionDefinition> functiondefinitions = sbmlModel.getListOfFunctionDefinitions();
		ListOf<Compartment> compartments = sbmlModel.getListOfCompartments();
		ListOf<Species> listOfSpecies = sbmlModel.getListOfSpecies();
		ListOf<Parameter> parameters = sbmlModel.getListOfParameters();
		ListOf<Rule> rules = sbmlModel.getListOfRules();
		ListOf<Reaction> reactions = sbmlModel.getListOfReactions();
		ListOf<Event> events = sbmlModel.getListOfEvents();
		
		mathOperators = new Vector<String>();

		mathOperators.add("exp");
		mathOperators.add("pow");
		mathOperators.add("root");
		mathOperators.add("sqrt"); // libsbml transformed root into sqrt !!
		mathOperators.add("eq");
		mathOperators.add("neq");
		mathOperators.add("gt");
		mathOperators.add("geq");
		mathOperators.add("lt");
		mathOperators.add("leq");
		mathOperators.add("sin");
		mathOperators.add("cos");
		mathOperators.add("tan");
		mathOperators.add("atan2");
		mathOperators.add("asin");
		mathOperators.add("acos");
		mathOperators.add("atan");
		mathOperators.add("sinh");
		mathOperators.add("cosh");
		mathOperators.add("tanh");
		mathOperators.add("log");
		mathOperators.add("log10");		
		mathOperators.add("ln");
		mathOperators.add("abs");
		mathOperators.add("pi");
		mathOperators.add("time");
		mathOperators.add("Time");
		mathOperators.add("delay");
		mathOperators.add("ceil");
		mathOperators.add("flr");
		
		// because of the e-notation
		mathOperators.add("e");
		mathOperators.add("E");
		
		// For the time variable (csymbol time)
		mathOperators.add("t");
		
		// This will be transformed into if/then/else statement
		// mathOperators.add("piecewise");
		mathOperators.add("if");
		mathOperators.add("then");
		mathOperators.add("else");

		// TODO : check sign produce for the event !!

		// TODO : SBML level 2 version 3 : InitialAssignment (first biomodel with one is out !!!)...
		// use the libSBML WS facility to remove InitialAssignment from the model ??
		
		// TODO : if there is a piecewise element inside a functionDefinition, we would need to flatten the functionDefinitions
		// of the model to be able to support properly the piecewise. Could be done with the libSBML WS facility too.
		// biomodels 316 and 317 have this problem + 255
		// May be we could define an xpp function with 3 parameters that will do the if/then/else, then use this function
		// everywhere ??	
		
		// TODO : units check consistency : see if the libsbml WS could provide something like that.
		
		// TODO : does XPP mind at all about long variable name nowadays (version 5.96 seems to be fine) !!!
		
		xppModel += "\n";
		
		try {
		// Function Definition
		for (FunctionDefinition functiondefinition : functiondefinitions) {
			buildIdMap(functiondefinition);
			
			String funcdefin = printFunctionDefinition(functiondefinition);
			
			xppModel += "\n# FunctionDefinition id = " + functiondefinition.getId();
			if (functiondefinition.isSetName()) {
				xppModel += ", name = " + functiondefinition.getName() + "\n";
			} else {
				xppModel += "\n";
			}
			if (funcdefin == null) {
				System.out.println("Inconsistent mathML operators in Function Definition");
				xppModel += "# Inconsistent mathML operators in Function Definition, function ignored";
			} else {
				xppModel += funcdefin + "\n\n";
			}
		}

		// Compartments
		for (Compartment compartment : compartments) {

			buildIdMap(compartment);

			if (compartment.isConstant()) {
				nbParameters++;
				xppModel +="\n";
				xppModel +=printConstantCompartment(compartment);
			} else {
				xppModel +=printCompartment(compartment);
			}

		}

		// Global Parameters
		for (Parameter parameter : parameters) {

			buildIdMap(parameter);

			if (parameter.isConstant()) {
				nbParameters++;
				xppModel +=printConstantParameter(parameter);
			} else {
				xppModel +=printParameter(parameter);
			}

		}

		// Species 
		// id map is needed here for the rules mathML replaceId
		for (Species species : listOfSpecies) {
			buildIdMap(species);

			if (!species.isHasOnlySubstanceUnits()) {
				if (species.getCompartmentInstance().getSpatialDimensions() > 0) {
					isHasSubstanceUnits.put(species, false);
				}
				if (species.getCompartmentInstance().getSpatialDimensions() == 0) {
					isHasSubstanceUnits.put(species, true);
				}
			} else if (species.isHasOnlySubstanceUnits()) {
				isHasSubstanceUnits.put(species, true);
			}

		}

		// Reactions Id Map : We need to build the id map for reactions before taking care of the rules
		// in case there are any reaction id inside the rules math formula.
		for (Reaction reaction : reactions) {

			buildIdMap(reaction);

		}
		
		// Rules
		for (Rule rule : rules) {

			String rulemath = null;
			
			if (rule instanceof AlgebraicRule) {
				rulemath = printAlgebraicRule(rule);
			} else { 
				rulemath = printRule(rule);
			}
			
			if (rulemath == null) {
				System.out.println("Inconsistent mathML operators in Rule : " + rule.toString());				
			} else {
				xppModel +=rulemath;
			}


		}

		// Reactions
		for (Reaction reaction : reactions) {

			String reactionmath = printReaction(reaction);
			if (reactionmath == null) {
				System.out.println("Inconsistent mathML operators in Reaction " + reaction.getId());
				xppModel += "# Inconsistent mathML operators in Reaction " + reaction.getId();
			} else {
				xppModel +=reactionmath;
			}
			products = reaction.getListOfProducts();
			reactants = reaction.getListOfReactants();

			for (SpeciesReference reactant : reactants) {

				Species species = reactant.getSpeciesInstance();
				String speciesFlux = speciesFluxMap.get(species);


				String stoichiometryStr = "1";
				double stoichiometry = reactant.getStoichiometry();
				StoichiometryMath stoichiometryMath = reactant.getStoichiometryMath();

				if (stoichiometryMath != null
						&& stoichiometryMath.isSetMath()) {
					stoichiometryStr = stoichiometryMath.getMath().toFormula();
				} else if (stoichiometry != 0) {
					stoichiometryStr = Double.toString(stoichiometry);
				}

				if (speciesFlux == null) {
					speciesFlux = new String();
				}
				if (speciesFlux.length() != 0) {
					speciesFlux += " + ";
				}
				speciesFlux += "(-" + stoichiometryStr + " * "
					+ XPPID.getXPPId(reaction.getId()) + ")";
				
				speciesFluxMap.put(species, speciesFlux);
				
				System.out.println("Reactant flux map : id = " + species.getId());
				
			}
						
			for (SpeciesReference product : products) {

				Species species = product.getSpeciesInstance();
				String speciesFlux = speciesFluxMap.get(species);

				String stoichiometryStr = "1";
				double stoichiometry = product.getStoichiometry();
				StoichiometryMath stoichiometryMath = product.getStoichiometryMath();

				if (stoichiometryMath != null
						&& stoichiometryMath.isSetMath()) {
					stoichiometryStr = stoichiometryMath.getMath().toFormula();
				} else if (stoichiometry != 0) {
					stoichiometryStr = Double.toString(stoichiometry);
				}

				if (speciesFlux == null) {
					speciesFlux = new String();
				}
				if (speciesFlux.length() != 0) {
					speciesFlux += " + ";
				}
				speciesFlux += "( " + stoichiometryStr + " * "
					+ XPPID.getXPPId(reaction.getId()) + ")";
				speciesFluxMap.put(species, speciesFlux);
			}
		}

		// Species
		for (Species species : listOfSpecies) {

			if (species.isConstant()) {
				nbParameters++;
				xppModel +=printConstantSpecies(species);
			} else {
				String speciesmath = printSpecies(species);
				
				if (speciesmath == null) {
					System.out.println("Inconsistent mathML operator in species " + species.getId()); // Should never happen
				} else {
					xppModel +=speciesmath;
				}
			}
		}

		
		// Events
		int i = 1;
		for (Event event : events) {

			xppModel += "\n";
				
			String eventId = event.getId();

			if (eventId == null || eventId.trim().length() == 0 || !idPattern.matcher(eventId).matches()) {
				eventId = "event" + i;
				event.setId(eventId);
			} 
			
			// System.out.println("Debug : Event id = " + eventId + ", " + event.getId());
			// TODO : put the metaid if defined, put an event comment !!?			
			
			xppModel += "# event : " + eventId + "\n";
			
			buildIdMap(event);
			
			i++;
			
			Delay delay = event.getDelay ();
			Trigger trigger = event.getTrigger ();
			ASTNode astTrigger = trigger.getMath();
			
			String infixASTTrigger = astTrigger.toFormula();
			infixASTTrigger = replaceIdInsideFormula(infixASTTrigger);
			
			if (trigger == null || !trigger.isSetMath()) {
				xppModel +="# the trigger of this event is null !!!\n";
				xppModel +="# event ignored.\n";
				continue;
			}

			if (infixASTTrigger == null) {
				xppModel +="# the trigger contain some unsupported math elements.\n";
				xppModel +="# event ignored.\n\n";				
				continue;
			}
			
			if (delay != null && delay.isSetMath()) {
				// output some comment and log with this message : ("Unable to handle events with delays");
				xppModel +="# unable to handle events with delays currently.\n";
				xppModel +="# event ignored.\n\n";
				continue;
			}
			
			
			
			xppModel +=XPPID.getXPPId(eventId) + "=if (" + infixASTTrigger + ") then (1.5) else (0.2)\n";
			xppModel +="global 1 {" + XPPID.getXPPId(eventId) + " - 1.1} {";
		
			int j = 1;
			int eventAssignmentSize = event.getNumEventAssignments();
			boolean invalidMath = false;
			
			for (EventAssignment eventAssignment : event.getListOfEventAssignments()) {
				String eventAssignmentMath = eventAssignment.getMath().toFormula();
				eventAssignmentMath = replaceIdInsideFormula(eventAssignmentMath);
				
				if (eventAssignmentMath == null) {
					invalidMath = true;

					if (j >= eventAssignmentSize) {
						xppModel +="}\n";
					}
					
					continue;
				}
				
				xppModel += eventAssignment.getVariable() + "=" + eventAssignmentMath;
				
				if (j < eventAssignmentSize) {
					xppModel +=";";
				} else {
					xppModel +="}\n";
				}
				
				j++;
			}
			
			if (eventAssignmentSize == 0) {
				xppModel +="}\n"; // closing the curly bracket in case of an invalid event with no eventAssignment 
			}
			if (invalidMath) {
				xppModel +="# some eventAssignment contained some unsupported math elements.\n";
				xppModel +="# the eventAssignment(s) was(were) ignored.\n\n";			
			}
			
		}

		if (xppFormulaCompiler.getPiecewiseMap().size() > 0) {
			
			xppModel += "\n\n# Piecewise functions : the mathML piecewise element is transformed into if/then/else expression\n\n";
			
			for (String piecewiseId : xppFormulaCompiler.getPiecewiseMap().keySet()) 
			{
				String ifThenElseFormula = xppFormulaCompiler.getPiecewiseMap().get(piecewiseId);
				ifThenElseFormula = replaceIdInsideFormula(ifThenElseFormula);
				
				System.out.println(" " + piecewiseId + " = " + xppFormulaCompiler.getPiecewiseMap().get(piecewiseId));
				
				if (ifThenElseFormula != null) {
					xppModel += piecewiseId + "=" + ifThenElseFormula + "\n\n";
				} else {
					xppModel += "# Inconsistent mathML operators found in piecewise \n";
					xppModel += "# formula is : " + ifThenElseFormula + " \n";
				}
			}
		}

		
		xppModel +="\n@ meth=cvode, tol=1e-6, atol=1e-8\n"
			+ "# @ maxstor=1e6\n"
			+ "@ bound=40000, total=200\n" + "done\n";

		} catch(AssertionError err) {
			xppModel = createHeader();
			xppModel += "\n#\n# " + err.getMessage() + "\n#\n";
		}
		
		XPPModel xppReturnModel = new XPPModel();
		xppReturnModel.setModelFromString(xppModel);
				
		return xppReturnModel;
		

	}
	
	
	private String translatePiecewise(String infixFormula, ASTNode astNode) {			
		
		// imbricated piecewise are fine as only simple if/then/else are created (test biomodels 248, 237)
		
		infixFormula = infixFormula.trim();
		int indexPiecewise = infixFormula.indexOf("piecewise");
		
		if (indexPiecewise != -1) {
			
			System.out.println("SBML2XPP : translatePiecewise : initial formula = " + infixFormula);
			
			try {
				infixFormula = astNode.compile(xppFormulaCompiler).toString();
			} catch (SBMLException e) {
				e.printStackTrace();
			}
			
			System.out.println("SBML2XPP : translatePiecewise : translated formula = \n" + infixFormula);
		}
		
		return infixFormula;
	}
	
	/**
	 * Function Definition(mathML) from SBML file is converted to infix notation by libSBML
	 *  and checked for supporting math functions.
	 *  Infix notation is passed as a Equation in XPP
	 *  
	 *  SBML: lambda(x,y,formula)
	 *  XPP : function_name(x,y) = formula
	 *  @param functiondefinition : mathML from SBML model
	 * 	@return : corresponding Supported equation for XPP 
	 * @throws SBMLException 
	 */
	private String printFunctionDefinition(FunctionDefinition functiondefinition) throws SBMLException {

		String inputformula = functiondefinition.getMath().toFormula();
		
		System.out.println("SBML2XPP : printFunctionDefinition : jsbml original math = " + inputformula);
		
		inputformula = inputformula.replace("lambda(", "");

		ArrayList<String> functionParameters = new ArrayList<String>();

		StringTokenizer stcomma = new StringTokenizer(inputformula, ",");
		
		StringBuilder funcDef = new StringBuilder();
		StringBuilder formula = new StringBuilder();
		formula.append("(");
		
		String functionname;

		int count = 0;
		int stCommaNb = stcomma.countTokens();

		/*
		 * uses ",  as String tokenizer " if single then a variable if more than
		 * one, check for," ", (, ), / and add it to formula
		 */
		while (stcomma.hasMoreTokens()) {
			
			String read = stcomma.nextToken().trim();
			count++;
			if (read.contains(" ") || read.contains(" * ")
					|| read.contains("/") || read.contains(")")
					|| read.contains("(")) 
			{
				formula.append(read);
				
				if (count < stCommaNb) {
					formula.append(",");
				}
			
			} else {
				functionParameters.add(read);
			}
		}

		// getting the xppid instead of functionid from FunctionDefinition
		functionname = functiondefinition.getId();
		String xppid = XPPID.getXPPId(functionname);
		funcDef.append(xppid + "(");
		
		// add the function parameters to the StringBuilder separated by ","
		for (int i = 0; i < functionParameters.size(); i++) {
			if (i < functionParameters.size() - 1) {
				funcDef.append(functionParameters.get(i) + ",");
			} else {
				funcDef.append(functionParameters.get(i));
			}
		}

		// We need to replace the ids inside the mathML in case of nested functionDefinitions with long names !!
		String formulaStr = replaceIdInsideFormula(formula.toString());

		funcDef.append(")=" + formulaStr);
		
		System.out.println("FunctionDefinition : id = " + functiondefinition.getId());
		System.out.println("FunctionDefinition : xpp version = " + funcDef.toString());
		
		if (matchMath(formulaStr, functionParameters, funcDef)) {
			return funcDef.toString();
		} else {
			String error = null;
			return error;
		}

	}

	/**
	 * Matches whether the elements in the formula are consistent with supported math operators <br />
	 * Function takes input formula, and Arraylist of valid names 
	 * 
	 * Mainly used for Function Definition
	 * 
	 * @param formula : Input formula to be checked
	 * @return : boolean whether math is supported or not
	 * 
	 */
	private boolean matchMath(String formula,
			ArrayList<String> additionalValidNames, StringBuilder xppSB) {
		boolean support = true;

		Matcher mathMatcher = idPattern.matcher(formula);
		ArrayList<String> checkoperator = new ArrayList<String>();
		while (mathMatcher.find()) {
			checkoperator.add(mathMatcher.group());
			// check for id
		}

		for (String check : checkoperator) {

			if (XPPID.getSBMLId(check) != null) {
			} else {
				if (mathOperators.contains(check) || check.startsWith("piecew")) 
				{
					// the String is valid
				} 
				else if (additionalValidNames != null
						&& additionalValidNames.contains(check)) 
				{
					// the String is valid
				} 
				else 
				{
					System.out.println("SBML2XPP : matchMath : the operator " + check + " is not supported by xpp");
					System.out.println("SBML2XPP : matchMath : the formula is : " + formula);
					xppSB.append("# the operator " + check + " is not supported by xpp\n");
					xppSB.append("# the formula is : " + formula + "\n");
					support = false;
				}
			}
		}

		return support;
	}

	/**
	 * 
	 * Matches whether the elements in the formula are consistent with supported math operators by {@link XPPID#checkXPPId()}
	 *  
	 * @param formula : Input formula to be checked
	 * @return : boolean whether math is supported or not
	 */
	private boolean matchMath(String formula, StringBuilder xppSB) {
		boolean support = true;

		Matcher mathMatcher = idPattern.matcher(formula);
		ArrayList<String> checkoperators = new ArrayList<String>();
		while (mathMatcher.find()) {
			
			checkoperators.add(mathMatcher.group());
			// check for id
		}

		for (String check : checkoperators) {
			if (XPPID.getSBMLId(check) != null) {
			} else {
				if (mathOperators.contains(check) || check.startsWith("piecew")) {
				} else {
					System.out.println("SBML2XPP : matchMath : the operator " + check + " is not supported by xpp");
					System.out.println("SBML2XPP : matchMath : the formula is : " + formula);
					xppSB.append("# the operator " + check + " is not supported by xpp\n");
					xppSB.append("# the formula is : " + formula + "\n");
					support = false;
				}

			}

		}

		return support;
	}

	/**
	 * Converts the math(reaction) to infix notation by libSBML, 
	 * Prints reaction information (Reaction id, name),  <br />
	 * Local parameters, Checks for consistent XPP parameter length by {@link XPPID#checkXPPId()}
	 *   
	 * @param reaction : Reaction element of SBML model
	 * @return : corresponding Infix reaction
	 * @throws SBMLException 
	 */
	private String printReaction(Reaction reaction) throws SBMLException {

		StringBuilder reactionStr = new StringBuilder();
		String reactionId = reaction.getId();
		
		// print comment
		reactionStr.append("\n# Reaction: id = " + reactionId);

		if (reaction.getName() != null
				&& reaction.getName().trim().length() != 0) {
			reactionStr.append(", name = " + reaction.getName());
		}

		reactionStr.append("\n");

		// print all local parameters
		KineticLaw kineticLaw = reaction.getKineticLaw();
		String kineticLawStr = "";

		if (kineticLaw != null) {
			kineticLawStr = kineticLaw.getMath().toFormula();

			ListOf<LocalParameter> localParameters = kineticLaw.getListOfParameters();

			for (LocalParameter parameter : localParameters) {

				buildIdMap(parameter, reaction);
				String parameterId = parameter.getId();
				String localParameterId = parameterId + "_" + reactionId;

	

				if (parameter.isSetValue()) {
					nbParameters++;
					reactionStr.append(printLocalParameter(parameter,
							localParameterId));
				} else {
					// Error, a local parameter should always be constant
					System.out.println("Warning !! the local parameter " + localParameterId
							+ " is not constant !!");
				}

				// replace other ids if they are not "xpp valid"

				kineticLawStr = replaceIdInsideFormula(kineticLawStr, parameterId,
						localParameterId);

			}

			// replace other ids if they are not "xpp valid"
			kineticLawStr = replaceIdInsideFormula(kineticLawStr);
			kineticLawStr = translatePiecewise(kineticLawStr, kineticLaw.getMath());

			// replace "+ -" by "-"
			kineticLawStr = replacePlusMinusInsideFormula(kineticLawStr);
		} else {			
			throw new AssertionError("The model cannot be converted as there are some kineticLaw undefined.");
		}

		reactionStr.append("\n" + XPPID.getXPPId(reaction.getId()) + "="
				+ kineticLawStr + "\n");
		
		System.out.println("Reaction : id = " + reactionId);
		
		// checks mathML for reaction
		if (matchMath(kineticLawStr.toString(), reactionStr))
			return reactionStr.toString();
		else
			return null;

	}

	/**
	 * Replaces the formula elements in reference to XPPid 
	 * Function takes formula, OldID and new Id
	 * @param formula : Any formula in SBML model
	 * @return : formula with changed/replaced Id's
	 */
	private String replaceIdInsideFormula(String formula, String oldId,
			String newId) {

		StringBuffer formulaWithIdsBuffer = new StringBuffer();

		Matcher formulaMatcher = idPattern.matcher(formula);

		while (formulaMatcher.find()) {
			String id = formulaMatcher.group().trim();

			if (id.equals(oldId)) {
				id = newId;
			}

			formulaMatcher.appendReplacement(formulaWithIdsBuffer, id);
		}

		formulaMatcher.appendTail(formulaWithIdsBuffer);

		return formulaWithIdsBuffer.toString();
	}

	/**
	 * Replaces the formula elements in reference to XPPid 
	 * 
	 * @param formula : Any formula in SBML model
	 * @return : formula with changed/replaced Id's
	 */
	 
	private String replaceIdInsideFormula(String formula) {

		StringBuffer formulaWithIdsBuffer = new StringBuffer();

		Matcher formulaMatcher = idPattern.matcher(formula);

		while (formulaMatcher.find()) {
			String id = formulaMatcher.group().trim();

			String newId = XPPID.getXPPId(id);

			if (newId != null) {
				formulaMatcher.appendReplacement(formulaWithIdsBuffer, newId);
			}
		}

		formulaMatcher.appendTail(formulaWithIdsBuffer);

		return formulaWithIdsBuffer.toString();
	}

	/**
	 * Appends the "+" or "-" sign to parameters/elements, accordingly when it is a reactant or a product  
	 * @param formula 
	 * @return : formula with changed sign. 
	 */
	private String replacePlusMinusInsideFormula(String formula) {

		StringBuffer formulaWithIdsBuffer = new StringBuffer();

		Matcher formulaMatcher = plusMinusPattern.matcher(formula);

		while (formulaMatcher.find()) {

			formulaMatcher.appendReplacement(formulaWithIdsBuffer, "- ");
		}

		formulaMatcher.appendTail(formulaWithIdsBuffer);

		return formulaWithIdsBuffer.toString();
	}

	/**
	 * Prints information on Local parameters <br />
	 * also calls the check for consistent XPPid length by {@link XPPID#checkXPPId()}
	 * @param parameter
	 * @param id
	 * @return
	 */
	private String printLocalParameter(LocalParameter parameter, String id) {
		StringBuilder paramStr = new StringBuilder();

		paramStr.append(printLocalParameterComment(parameter));
		String xppId = XPPID.getXPPId(id);

		paramStr.append("par " + xppId + "=" + parameter.getValue() + "\n\n");

		return paramStr.toString();

	}


	/**
	 * using libSBML changes the Rules(mathML) to Infix notation
	 *  
	 * @param rule
	 * @return
	 * @throws SBMLException 
	 */
	private String printRule(Rule rule) throws SBMLException {
		
		StringBuilder ruleStr = new StringBuilder();
		String variableId = null;
		
		/*Getting VariableId*/
		if(rule.isRate()) {
			variableId = ((RateRule)rule).getVariable();
			
		}
		else if(rule.isAssignment()) {
			variableId = ((AssignmentRule)rule).getVariable();
		}
		
		String xppId = XPPID.getXPPId(variableId);
		String mathMLStr = rule.getMath().toFormula();
		mathMLStr = replaceIdInsideFormula(mathMLStr);
		mathMLStr = translatePiecewise(mathMLStr, rule.getMath());
		
		System.out.println("Rule : variable = " + variableId);

		ruleStr.append("\n# " + rule.getElementName() + ": variable = "
				+ variableId + "\n");

		if (matchMath(mathMLStr, ruleStr)) {

			// mathMLStr = translatePiecewise(mathMLStr);

			if (rule.isRate()) {
				
				// Get the initial values or have that done before ?
				RateRule variable = (RateRule)rule;
				String initialValue = "TODO";
				if (variable.getVariableInstance() instanceof Compartment) {
					initialValue = "" + ((Compartment) variable.getVariableInstance()).getSize();
				} else if (variable.getVariableInstance() instanceof Species) {
					
					// TODO : check which one of InitialAmount or InitialConcentration we should use !!!
					initialValue = "" + ((Species) variable.getVariableInstance()).getInitialAmount();
					
				} else if(variable.getVariableInstance() instanceof Parameter) {
					initialValue = "" + ((Parameter) variable.getVariableInstance()).getValue();
				}  
				
				ruleStr.append("init " + xppId + "=" + initialValue + "\n");
				ruleStr.append("d" + xppId + "/dt=" + mathMLStr + "\n");
				
			} else if (rule.isAssignment()) {
				ruleStr.append("" + xppId + "=" + mathMLStr + "\n");
				ruleStr.append("aux " + xppId + "=" + xppId + "\n");
			}
			
			
		} else {
			// Print a warning to say that there are some unsupported functions
			System.out.println("Rule " + variableId + " ignored : there are some unsupported functions !!");
			ruleStr.append("#Rule ignored : there are some unsupported functions !!\n");
		}

		return ruleStr.toString();

	}

	/**
	 * using libSBML changes the Rules(mathML) to Infix notation
	 *  
	 * @param rule
	 * @return
	 * @throws SBMLException 
	 */
	private String printAlgebraicRule(Rule rule) throws SBMLException {
		
		StringBuilder ruleStr = new StringBuilder();

		String mathMLStr = rule.getMath().toFormula();
		mathMLStr = replaceIdInsideFormula(mathMLStr);
		
		System.out.println("Algebraic Rule");
		
		if (matchMath(mathMLStr, ruleStr)) {
			ruleStr.append("# " + rule.getElementName() + "\n");
			ruleStr.append("# Warning, " + rule.getElementName() + " are not supported at the moment.\n");
			ruleStr.append("# " + mathMLStr + " = 0\n");
			
			return ruleStr.toString();
		} else {
			// TODO : Print a warning to say that there are some unsupported functions
			return null;
		}


	}

	/**
	 * Checks for Consistent XPPid {@link XPPID#checkXPPId()}<br/>
	 * Checks for initial Concentration and/or Initial Amount is defined
	 * Checks for Spatial Dimensions(Compartments), and accordingly returns Species Units <br/>
	 * Checks for Species Boundary Condition and Rules, 
	 * 
	 * @param species : Species Element of SBML Model
	 * @return : SpeciesFluxMap 
	 */
	private String printSpecies(Species species) {
		StringBuilder speciesStr = new StringBuilder();
		String checkmath = null;
		speciesStr.append(printSpeciesComment(species));

		String id = species.getId();
		
		boolean isAffectedByRule = false;
		boolean needInit = true;
		boolean auxDeclaration = false;
		
		for (Rule rule : sbmlModel.getListOfRules()) {
			if (rule instanceof ExplicitRule) {
				if(id.equals(((ExplicitRule) rule).getVariable())) { 
					isAffectedByRule = true;
				
					needInit = false; // The init is done when writing the rule in fact
				}
			}
		}

		id = XPPID.getXPPId(species.getId());
		
		String xppModifier = "init "; 
		
		if (!isAffectedByRule && (!hasReaction(id) || (hasReaction(id) && species.isBoundaryCondition() == true))) {
			xppModifier = "par "; 
			auxDeclaration = true;
			// int nbEvent = getNbAffectingEvent(species); Do we check to see if some event are involved ??
		}

		if (needInit) {
			if (species.isSetInitialAmount()
					&& species.isSetInitialConcentration()) {

				throw new AssertionError("Error in model, both Initial concentration and Initial amount defined");

			} else if (species.isSetInitialAmount()) {
				speciesStr.append(xppModifier + id + "=" + species.getInitialAmount()
						+ "\n");

			} else if (species.isSetInitialConcentration()) {
				speciesStr.append(xppModifier + id + "="
						+ species.getInitialConcentration() + "\n");

			} else {
				speciesStr.append("#WARNING : no initial state for this species\n");
				speciesStr.append(xppModifier + id + "=0\n");
			}
		}

		if (auxDeclaration) {
			speciesStr.append("aux " + id + "=" + id + "\n");
		}
		
		if (species.isBoundaryCondition()) {
			if (!isAffectedByRule && !hasEvent(species.getId())) {

				// speciesStr.append("\td" + id + "/dt=0" + "\n");
				speciesStr
				.append("#WARNING speciesID: "
						+ species.getId()
						+ ", constant= false "
						+ " , boundaryCondition = "
						+ species.isBoundaryCondition()
						+ " but is not involved in assignmentRule, rateRule or events !"
						+ "\n");

			}
		} else if (!species.isBoundaryCondition()) {
			// valid assignment rule/rate rule
			if (!isAffectedByRule) {
				// check if species is reactant/product
				if (speciesFluxMap.get(species) != null
						&& !(isHasSubstanceUnits.get(species))) {

					String sbmlId = species.getCompartmentInstance().getId();
					String xppId = XPPID.getXPPId(sbmlId);
					checkmath = " (1/(" + xppId	+ "))*(" + speciesFluxMap.get(species) + ")";
					speciesStr.append("d" + id + "/dt=" + "(1/(" + xppId
							+ "))*(" + speciesFluxMap.get(species) + ")\n");
				} else if (speciesFluxMap.get(species) != null) {
					speciesStr.append("d" + id + "/dt="
							+ speciesFluxMap.get(species) + "\n");

				}
			}
		}
		
		if (checkmath != null) {
			if (matchMath(checkmath, speciesStr))
				return speciesStr.toString();
			else
				return null;
		}else
			return speciesStr.toString();
	}

	/**
	 * Checks if an SBML element, represented by the id passed as argument, is affected by a rule. 
	 *  
	 * @param id an SBML element id.
	 * @return : true if element is affected by a rule  
	 */
	private boolean hasRule(String id) {
		for (Rule rule : sbmlModel.getListOfRules()) {
			if (rule instanceof ExplicitRule) {
				if (id.equals(((ExplicitRule) rule).getVariable())) {
					return true;
				}
			}

		}
		
		return false;
	}
	
	/**
	 * Checks if an SBML element, represented by the id passed as argument, is affected by an event. 
	 *  
	 * @param id an SBML element id.
	 * @return : true if element is affected by an event  
	 */
	private boolean hasEvent(String id) {
		for (Event event : sbmlModel.getListOfEvents()) {
			
			for (EventAssignment eventAssgnt : event.getListOfEventAssignments()) {
				if (eventAssgnt.getVariable().equals(id)) {
					return true;
				}
			}
		}
		
		return false;
	}

	/**
	 * Checks if a Species, represented by the id passed as argument, is used as reactant or product in a reaction. 
	 *  
	 * @param id a Species id.
	 * @return : true if the species is affected by Reaction  
	 */
	private boolean hasReaction(String id) {
		for (Reaction reaction : sbmlModel.getListOfReactions()) {
			
			for (SpeciesReference speciesRef : reaction.getListOfReactants()) {
				if (speciesRef.getSpecies().equals(id)) {
					return true;
				}
			}
			for (SpeciesReference speciesRef : reaction.getListOfProducts()) {
				if (speciesRef.getSpecies().equals(id)) {
					return true;
				}
			}
		}
		
		return false;
	}
	
	/**
	 * Prints Constant species and calls {@link XPPID#checkXPPId()}
	 * Also checks for Intial concentration or amount defined
	 * @param species
	 * @return
	 */
	private String printConstantSpecies(Species species) {
		StringBuilder speciesStr = new StringBuilder();

		speciesStr.append(printSpeciesComment(species));

		String id = XPPID.getXPPId(species.getId());

		if (species.isSetInitialAmount()
				&& species.isSetInitialConcentration()) {

			throw new AssertionError("Error in model, both Initial concentration and Initial amount defined");

		} else if (species.isSetInitialAmount()) {
			speciesStr.append("par " + id + "=" + species.getInitialAmount()
					+ "\n\n");

		} else if (species.isSetInitialConcentration()) {
			
			speciesStr.append("par " + id + "="
					+ species.getInitialConcentration() + "\n\n");
		}
		// todo completed
		return speciesStr.toString();
	}

	/**
	 * Adds Species Information <br />
	 * Checks for Rule and Boundary condition for species(!= Constant)
	 * 
	 * @param species : Element in SBML model
	 * @return : species Flux Map
	 */
	private String printSpeciesComment(Species species) {

		StringBuilder commentStr = new StringBuilder();
		String id = species.getId();
		String name = species.getName();

		if (name == null || name.trim().length() == 0) {
			name = id;
		}

		commentStr.append("\n# Species: ");
		commentStr.append("  id = " + id);
		commentStr.append(", name = " + name);

		if (species.isConstant()) {
			commentStr.append(", constant");
		} else {
			// check for boundary condition and then display
			if (species.isBoundaryCondition()) {
				if (hasRule(id)) {
					commentStr.append(", involved in a rule ");
				} else if (!hasRule(id)) {
					
				}
			} else if (!species.isBoundaryCondition()) {
				// affected by rules or kinetic law not both
				if (hasRule(id)) {
					commentStr.append(", defined in a rule ");
				} else if (speciesFluxMap.get(species) != null) {
					commentStr.append(", affected by kineticLaw\n");
				} else {
					commentStr.append("\n# Warning species is not changed by either rules or reactions\n");
				}
			}

			int nbEvent = getNbAffectingEvent(species);
			
			if (nbEvent > 0) {
				commentStr.append("# Species is changed by " + nbEvent + " event(s)");
			}

		}
		commentStr.append("\n");

		return commentStr.toString();
	}

	
	/**
	 * Returns the number of event that have an assignment affecting the element passed as argument.
	 * 
	 * @param element and SBMl element
	 * 
	 * @return the number of event that have an assignment affecting the element passed as argument.
	 */
	private int getNbAffectingEvent(SBase element) {
		
		int n = 0;
		if(element instanceof NamedSBase) {
			String elementId = ((NamedSBase) element).getId();
			
			for (Event event : sbmlModel.getListOfEvents()) {
				for (EventAssignment eventAssignment : event.getListOfEventAssignments()) {
					if (elementId.equals(eventAssignment.getVariable())) {
						n++;
						break;
					}
				}
			}
		}
		
		return n;
	}
	
	

	/**
	 * 
	 * Adds parameter information as comments<br/> 
	 * Checks for whether parameter has a rule , or else gives a warning
	 *  
	 * @param : Parameter element of SBML
	 * @return : parameter information with Equation
	 */
	private String printParameter(Parameter parameter) {
		StringBuilder paramStr = new StringBuilder();

		paramStr.append(printParameterComment(parameter));
		
		boolean hasRule = hasRule(parameter.getId());
		
		if (!hasRule && !hasEvent(parameter.getId())) {
			paramStr.append("# Warning parameter " + parameter.getId()
					+ " is not constant, it should be controled by a Rule and/or events" + "\n");
		}
		
		if (!hasRule) {
			String id = XPPID.getXPPId(parameter.getId());

			paramStr.append("par " + id + "=" + parameter.getValue() + "\n");
		}
		
		return paramStr.toString();
	}

	/**
	 * 
	 * Adds parameter information as comments and 
	 * limits and changes length of elements wrt XPP
	 * 
	 * @param parameter : Parameter Element of SBML model
	 * @return : constant Parameter with initial value
	 */
	private String printConstantParameter(Parameter parameter) {
		StringBuilder paramStr = new StringBuilder();

		paramStr.append(printParameterComment(parameter));

		String id = XPPID.getXPPId(parameter.getId());

		paramStr.append("par " + id + "=" + parameter.getValue() + "\n");

		return paramStr.toString();
	}

	/**
	 * Adds parameter information as comments <br /> 
	 * Checks whether parameter is a local parameter or a global parameter
	 * 
	 * @param Parameter :  Element of SBML Model
	 * @return : parameter information as string
	 */
	private String printParameterComment(Parameter parameter) {

		StringBuilder commentStr = new StringBuilder();

		String id = parameter.getId();
		String name = parameter.getName();

		if (name == null || name.trim().length() == 0) {
			name = id;
		}

		commentStr.append("\n# Parameter: ");
		commentStr.append("  id =  " + id);
		commentStr.append(", name = " + name);

		// find isConstant()
		if (parameter.isConstant()) {
			commentStr.append(", constant");
		}
		if (hasRule(id)) {
			commentStr.append(", defined by a Rule");
		}

		commentStr.append("\n");

		return commentStr.toString();
	}
	
	/**
	 * Adds parameter information as comments <br /> 
	 * Checks whether parameter is a local parameter or a global parameter
	 * 
	 * @param Parameter :  Element of SBML Model
	 * @return : parameter information as string
	 */
	private String printLocalParameterComment(LocalParameter parameter) {

		StringBuilder commentStr = new StringBuilder();

		String id = parameter.getId();
		String name = parameter.getName();

		if (name == null || name.trim().length() == 0) {
			name = id;
		}

		commentStr.append("# Local Parameter: ");
		commentStr.append("  id =  " + id);
		commentStr.append(", name = " + name);
		commentStr.append("\n");

		return commentStr.toString();
	}

	/**
	 * Adds compartment information as comments<br/> 
	 * Checks for whether compartment has a rule , or else gives a warning
	 * 
	 * @param compartment : Compartment element of SBML
	 * @return : Compartment information with Equation
	 */
	private String printCompartment(Compartment compartment) {

		StringBuilder compStr = new StringBuilder();

		compStr.append(printCompartmentComment(compartment));
		if (!hasRule(compartment.getId())) {
			compStr.append("# Warning compartment " + compartment.getId()
					+ " has no rule and is not constant" + "\n");
		}

		return compStr.toString();
	}

	/**
	 * Prints compartment comments: 
	 * id, name, constant or defined by a rule
	 * @param : compartment : Compartment element from SBML model
	 * @return : compartment information
	 */
	private String printCompartmentComment(Compartment compartment) {

		StringBuilder compCommentStr = new StringBuilder();

		String id = compartment.getId();
		String name = compartment.getName();

		if (name == null || name.trim().length() == 0) {
			name = id;
		}

		compCommentStr.append("# Compartment: id = " + id + ", name = " + name);

		if (compartment.isConstant()) {
			compCommentStr.append(", constant");
		} else if (hasRule(id)) {
			compCommentStr.append(", defined by a Rule");
		}

		compCommentStr.append("\n");

		return compCommentStr.toString();
	}

	/**
	 * Adds compartment information as comments and 
	 * limits and changes length of elements wrt XPP
	 * @param compartment : Compartment element of SBML model 
	 * @return : constant compartment with initial size
	 */
	private String printConstantCompartment(Compartment compartment) {

		StringBuilder compStr = new StringBuilder();

		compStr.append(printCompartmentComment(compartment));

		String id = XPPID.getXPPId(compartment.getId());

		compStr.append("par " + id + "=" + compartment.getSize() + "\n");

		return compStr.toString();

	}

	private void buildIdMap(SBase element) {

		String id = ((NamedSBase)element).getId();

		XPPID xppId = new XPPID(id);
		xppId.checkXPPId();
	}

	private void buildIdMap(LocalParameter parameter, Reaction reaction) {

		String id = parameter.getId();
		XPPID xppId = new XPPID(id, reaction.getId());
		xppId.checkXPPId();

	}




	public GeneralModel convert(GeneralModel model) {
		
		try {
			return xppExport((SBMLModel)model);
		} catch (SBMLException e) {
			e.printStackTrace();
		}

		return null;
	}


	public String getResultExtension() {
		return ".xpp";
	}
}
